<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Range-v3: Algorithms</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Range-v3
   </div>
   <div id="projectbrief">Range algorithms, views, and actions for the Standard Library</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__group-algorithms.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Algorithms</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<p>Iterator- and range-based algorithms, like the standard algorithms. </p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga4ec55cd1aee7604d0c5a335fb3d8641b"><td class="memTemplParams" colspan="2"><a id="ga4ec55cd1aee7604d0c5a335fb3d8641b"></a>
template&lt;typename I1 , typename I2 , typename O &gt; </td></tr>
<tr class="memitem:ga4ec55cd1aee7604d0c5a335fb3d8641b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::binary_transform_result</b> = detail::in1_in2_out_result&lt; I1, I2, O &gt;</td></tr>
<tr class="separator:ga4ec55cd1aee7604d0c5a335fb3d8641b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58e197a7893ec8659fb7e2513130f7cf"><td class="memTemplParams" colspan="2"><a id="ga58e197a7893ec8659fb7e2513130f7cf"></a>
template&lt;typename I , typename O &gt; </td></tr>
<tr class="memitem:ga58e197a7893ec8659fb7e2513130f7cf"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::copy_backward_result</b> = detail::in_out_result&lt; I, O &gt;</td></tr>
<tr class="separator:ga58e197a7893ec8659fb7e2513130f7cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a179c5b7b8620b7fd95dc315cab0a39"><td class="memTemplParams" colspan="2"><a id="ga5a179c5b7b8620b7fd95dc315cab0a39"></a>
template&lt;typename I , typename O &gt; </td></tr>
<tr class="memitem:ga5a179c5b7b8620b7fd95dc315cab0a39"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::copy_if_result</b> = detail::in_out_result&lt; I, O &gt;</td></tr>
<tr class="separator:ga5a179c5b7b8620b7fd95dc315cab0a39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2ac60776de9431e79a65c4897bd2e3d"><td class="memTemplParams" colspan="2"><a id="gae2ac60776de9431e79a65c4897bd2e3d"></a>
template&lt;typename I , typename O &gt; </td></tr>
<tr class="memitem:gae2ac60776de9431e79a65c4897bd2e3d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::copy_n_result</b> = detail::in_out_result&lt; I, O &gt;</td></tr>
<tr class="separator:gae2ac60776de9431e79a65c4897bd2e3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab309c6678ed7ad0eea22415f3d66514a"><td class="memTemplParams" colspan="2"><a id="gab309c6678ed7ad0eea22415f3d66514a"></a>
template&lt;typename I , typename O &gt; </td></tr>
<tr class="memitem:gab309c6678ed7ad0eea22415f3d66514a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::copy_result</b> = detail::in_out_result&lt; I, O &gt;</td></tr>
<tr class="separator:gab309c6678ed7ad0eea22415f3d66514a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84025d197692778e238c2143ee2dcdee"><td class="memTemplParams" colspan="2"><a id="ga84025d197692778e238c2143ee2dcdee"></a>
template&lt;typename I , typename F &gt; </td></tr>
<tr class="memitem:ga84025d197692778e238c2143ee2dcdee"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::for_each_result</b> = detail::in_fun_result&lt; I, F &gt;</td></tr>
<tr class="separator:ga84025d197692778e238c2143ee2dcdee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0cd85c482465e0fef02aec6733ec5e8a"><td class="memTemplParams" colspan="2"><a id="ga0cd85c482465e0fef02aec6733ec5e8a"></a>
template&lt;typename O , typename F &gt; </td></tr>
<tr class="memitem:ga0cd85c482465e0fef02aec6733ec5e8a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::generate_n_result</b> = detail::out_fun_result&lt; O, F &gt;</td></tr>
<tr class="separator:ga0cd85c482465e0fef02aec6733ec5e8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b78921a0e76ce435f8c180041296192"><td class="memTemplParams" colspan="2"><a id="ga4b78921a0e76ce435f8c180041296192"></a>
template&lt;typename O , typename F &gt; </td></tr>
<tr class="memitem:ga4b78921a0e76ce435f8c180041296192"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::generate_result</b> = detail::out_fun_result&lt; O, F &gt;</td></tr>
<tr class="separator:ga4b78921a0e76ce435f8c180041296192"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4fb3de5f6f61105bed9816cbbe1c20e4"><td class="memTemplParams" colspan="2"><a id="ga4fb3de5f6f61105bed9816cbbe1c20e4"></a>
template&lt;typename I0 , typename I1 , typename O &gt; </td></tr>
<tr class="memitem:ga4fb3de5f6f61105bed9816cbbe1c20e4"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::merge_result</b> = detail::in1_in2_out_result&lt; I0, I1, O &gt;</td></tr>
<tr class="separator:ga4fb3de5f6f61105bed9816cbbe1c20e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2551631b044f18c25ebf252d89ab62d1"><td class="memTemplParams" colspan="2"><a id="ga2551631b044f18c25ebf252d89ab62d1"></a>
template&lt;typename I &gt; </td></tr>
<tr class="memitem:ga2551631b044f18c25ebf252d89ab62d1"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::minmax_element_result</b> = detail::min_max_result&lt; I, I &gt;</td></tr>
<tr class="separator:ga2551631b044f18c25ebf252d89ab62d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33d3732bfda9763bacb492f678c49ac2"><td class="memTemplParams" colspan="2"><a id="ga33d3732bfda9763bacb492f678c49ac2"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga33d3732bfda9763bacb492f678c49ac2"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::minmax_result</b> = detail::min_max_result&lt; T, T &gt;</td></tr>
<tr class="separator:ga33d3732bfda9763bacb492f678c49ac2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga228c0cdeb71847092b416b855e17c017"><td class="memTemplParams" colspan="2"><a id="ga228c0cdeb71847092b416b855e17c017"></a>
template&lt;typename I1 , typename I2 &gt; </td></tr>
<tr class="memitem:ga228c0cdeb71847092b416b855e17c017"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::mismatch_result</b> = detail::in1_in2_result&lt; I1, I2 &gt;</td></tr>
<tr class="separator:ga228c0cdeb71847092b416b855e17c017"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3ddbe128fcdd14998784890ae88172c"><td class="memTemplParams" colspan="2"><a id="gaf3ddbe128fcdd14998784890ae88172c"></a>
template&lt;typename I , typename O &gt; </td></tr>
<tr class="memitem:gaf3ddbe128fcdd14998784890ae88172c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::move_backward_result</b> = detail::in_out_result&lt; I, O &gt;</td></tr>
<tr class="separator:gaf3ddbe128fcdd14998784890ae88172c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa9e56e40c245536a73cd3c4479aa71f0"><td class="memTemplParams" colspan="2"><a id="gaa9e56e40c245536a73cd3c4479aa71f0"></a>
template&lt;typename I , typename O &gt; </td></tr>
<tr class="memitem:gaa9e56e40c245536a73cd3c4479aa71f0"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::move_result</b> = detail::in_out_result&lt; I, O &gt;</td></tr>
<tr class="separator:gaa9e56e40c245536a73cd3c4479aa71f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga196586ea2693c3b679d7c75c8c8c4eb2"><td class="memTemplParams" colspan="2"><a id="ga196586ea2693c3b679d7c75c8c8c4eb2"></a>
template&lt;typename I , typename O0 , typename O1 &gt; </td></tr>
<tr class="memitem:ga196586ea2693c3b679d7c75c8c8c4eb2"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::partition_copy_result</b> = detail::in_out1_out2_result&lt; I, O0, O1 &gt;</td></tr>
<tr class="separator:ga196586ea2693c3b679d7c75c8c8c4eb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81824d68277efdaa55addad2b5a1ab09"><td class="memTemplParams" colspan="2"><a id="ga81824d68277efdaa55addad2b5a1ab09"></a>
template&lt;typename I , typename O &gt; </td></tr>
<tr class="memitem:ga81824d68277efdaa55addad2b5a1ab09"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::remove_copy_if_result</b> = detail::in_out_result&lt; I, O &gt;</td></tr>
<tr class="separator:ga81824d68277efdaa55addad2b5a1ab09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacbea707ae03721b200a22fe6918920d8"><td class="memTemplParams" colspan="2"><a id="gacbea707ae03721b200a22fe6918920d8"></a>
template&lt;typename I , typename O &gt; </td></tr>
<tr class="memitem:gacbea707ae03721b200a22fe6918920d8"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::remove_copy_result</b> = detail::in_out_result&lt; I, O &gt;</td></tr>
<tr class="separator:gacbea707ae03721b200a22fe6918920d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4f4af78a9add9145c784b58d209e16e"><td class="memTemplParams" colspan="2"><a id="gaf4f4af78a9add9145c784b58d209e16e"></a>
template&lt;typename I , typename O &gt; </td></tr>
<tr class="memitem:gaf4f4af78a9add9145c784b58d209e16e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::replace_copy_if_result</b> = detail::in_out_result&lt; I, O &gt;</td></tr>
<tr class="separator:gaf4f4af78a9add9145c784b58d209e16e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf2b15655eb4ca83a6615695d37dc191"><td class="memTemplParams" colspan="2"><a id="gadf2b15655eb4ca83a6615695d37dc191"></a>
template&lt;typename I , typename O &gt; </td></tr>
<tr class="memitem:gadf2b15655eb4ca83a6615695d37dc191"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::replace_copy_result</b> = detail::in_out_result&lt; I, O &gt;</td></tr>
<tr class="separator:gadf2b15655eb4ca83a6615695d37dc191"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7bff287e5ec676e01a086ac147d4b618"><td class="memTemplParams" colspan="2"><a id="ga7bff287e5ec676e01a086ac147d4b618"></a>
template&lt;typename I , typename O &gt; </td></tr>
<tr class="memitem:ga7bff287e5ec676e01a086ac147d4b618"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::reverse_copy_result</b> = detail::in_out_result&lt; I, O &gt;</td></tr>
<tr class="separator:ga7bff287e5ec676e01a086ac147d4b618"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaebb905dac3fee120cf77b39e821c277c"><td class="memTemplParams" colspan="2"><a id="gaebb905dac3fee120cf77b39e821c277c"></a>
template&lt;typename I , typename O &gt; </td></tr>
<tr class="memitem:gaebb905dac3fee120cf77b39e821c277c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::rotate_copy_result</b> = detail::in_out_result&lt; I, O &gt;</td></tr>
<tr class="separator:gaebb905dac3fee120cf77b39e821c277c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8571d401e506014ea1a86618ca01545f"><td class="memTemplParams" colspan="2"><a id="ga8571d401e506014ea1a86618ca01545f"></a>
template&lt;typename I , typename O &gt; </td></tr>
<tr class="memitem:ga8571d401e506014ea1a86618ca01545f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::sample_result</b> = detail::in_out_result&lt; I, O &gt;</td></tr>
<tr class="separator:ga8571d401e506014ea1a86618ca01545f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46e34ec570ccc79f695689635145bed4"><td class="memTemplParams" colspan="2"><a id="ga46e34ec570ccc79f695689635145bed4"></a>
template&lt;typename I , typename O &gt; </td></tr>
<tr class="memitem:ga46e34ec570ccc79f695689635145bed4"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::set_difference_result</b> = detail::in1_out_result&lt; I, O &gt;</td></tr>
<tr class="separator:ga46e34ec570ccc79f695689635145bed4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa40276d355563038380b94ca8c500cd2"><td class="memTemplParams" colspan="2"><a id="gaa40276d355563038380b94ca8c500cd2"></a>
template&lt;typename I1 , typename I2 , typename O &gt; </td></tr>
<tr class="memitem:gaa40276d355563038380b94ca8c500cd2"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::set_symmetric_difference_result</b> = detail::in1_in2_out_result&lt; I1, I2, O &gt;</td></tr>
<tr class="separator:gaa40276d355563038380b94ca8c500cd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa28c664ec5818d4c1e4458486d109519"><td class="memTemplParams" colspan="2"><a id="gaa28c664ec5818d4c1e4458486d109519"></a>
template&lt;typename I1 , typename I2 , typename O &gt; </td></tr>
<tr class="memitem:gaa28c664ec5818d4c1e4458486d109519"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::set_union_result</b> = detail::in1_in2_out_result&lt; I1, I2, O &gt;</td></tr>
<tr class="separator:gaa28c664ec5818d4c1e4458486d109519"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a91c5c1590ec2c0cf1a56ea2e363dea"><td class="memTemplParams" colspan="2"><a id="ga3a91c5c1590ec2c0cf1a56ea2e363dea"></a>
template&lt;typename I1 , typename I2 &gt; </td></tr>
<tr class="memitem:ga3a91c5c1590ec2c0cf1a56ea2e363dea"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::swap_ranges_result</b> = detail::in1_in2_result&lt; I1, I2 &gt;</td></tr>
<tr class="separator:ga3a91c5c1590ec2c0cf1a56ea2e363dea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef72d2db7ea1c57f60101e18336e4037"><td class="memTemplParams" colspan="2"><a id="gaef72d2db7ea1c57f60101e18336e4037"></a>
template&lt;typename I , typename O &gt; </td></tr>
<tr class="memitem:gaef72d2db7ea1c57f60101e18336e4037"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::unary_transform_result</b> = detail::in_out_result&lt; I, O &gt;</td></tr>
<tr class="separator:gaef72d2db7ea1c57f60101e18336e4037"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf7ea4487e401b787c778cbc28e43913d"><td class="memTemplParams" colspan="2"><a id="gaf7ea4487e401b787c778cbc28e43913d"></a>
template&lt;typename I , typename O &gt; </td></tr>
<tr class="memitem:gaf7ea4487e401b787c778cbc28e43913d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::unique_copy_result</b> = detail::in_out_result&lt; I, O &gt;</td></tr>
<tr class="separator:gaf7ea4487e401b787c778cbc28e43913d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga144612fc146861f9979b3e6e25268732"><td class="memTemplParams" colspan="2">template&lt;typename I , typename S , typename C  = equal_to, typename P  = identity&gt; </td></tr>
<tr class="memitem:ga144612fc146861f9979b3e6e25268732"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga144612fc146861f9979b3e6e25268732">ranges::adjacent_find</a> (I first, S last, C pred=C{}, P proj=P{}) -&gt; I requires forward_iterator&lt; I &gt; &amp;&amp;sentinel_for&lt; S, I &gt; &amp;&amp;indirect_relation&lt; C, projected&lt; I, P &gt;&gt;</td></tr>
<tr class="memdesc:ga144612fc146861f9979b3e6e25268732"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>adjacent_find</code>  <a href="group__group-algorithms.html#ga144612fc146861f9979b3e6e25268732">More...</a><br /></td></tr>
<tr class="separator:ga144612fc146861f9979b3e6e25268732"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac18173d384f683bde768744166ae5907"><td class="memTemplParams" colspan="2">template&lt;typename Rng , typename C  = equal_to, typename P  = identity&gt; </td></tr>
<tr class="memitem:gac18173d384f683bde768744166ae5907"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gac18173d384f683bde768744166ae5907">ranges::adjacent_find</a> (Rng &amp;&amp;rng, C pred=C{}, P proj=P{}) -&gt; safe_iterator_t&lt; Rng &gt; requires forward_range&lt; Rng &gt; &amp;&amp;indirect_relation&lt; C, projected&lt; iterator_t&lt; Rng &gt;, P &gt;&gt;</td></tr>
<tr class="separator:gac18173d384f683bde768744166ae5907"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d08c6a9c28092deaa0a55dfc92fd1cd"><td class="memTemplParams" colspan="2">template&lt;typename I , typename S , typename Pred , typename Proj  = identity&gt; </td></tr>
<tr class="memitem:ga2d08c6a9c28092deaa0a55dfc92fd1cd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga2d08c6a9c28092deaa0a55dfc92fd1cd">ranges::adjacent_remove_if</a> (I first, S last, Pred pred={}, Proj proj={}) -&gt; I requires permutable&lt; I &gt; &amp;&amp;sentinel_for&lt; S, I &gt; &amp;&amp;indirect_relation&lt; Pred, projected&lt; I, Proj &gt;&gt;</td></tr>
<tr class="memdesc:ga2d08c6a9c28092deaa0a55dfc92fd1cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">function <code>adjacent_remove_if</code>  <a href="group__group-algorithms.html#ga2d08c6a9c28092deaa0a55dfc92fd1cd">More...</a><br /></td></tr>
<tr class="separator:ga2d08c6a9c28092deaa0a55dfc92fd1cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7eb3423653bb64e8fec6c9103d0b2fd9"><td class="memTemplParams" colspan="2">template&lt;typename Rng , typename Pred , typename Proj  = identity&gt; </td></tr>
<tr class="memitem:ga7eb3423653bb64e8fec6c9103d0b2fd9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga7eb3423653bb64e8fec6c9103d0b2fd9">ranges::adjacent_remove_if</a> (Rng &amp;&amp;rng, Pred pred, Proj proj={}) -&gt; safe_iterator_t&lt; Rng &gt; requires forward_range&lt; Rng &gt; &amp;&amp;indirect_relation&lt; Pred, projected&lt; iterator_t&lt; Rng &gt;, Proj &gt;&gt; &amp;&amp;permutable&lt; iterator_t&lt; Rng &gt;&gt;</td></tr>
<tr class="separator:ga7eb3423653bb64e8fec6c9103d0b2fd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0fb576d41b10d5dea5641a244cca92b"><td class="memTemplParams" colspan="2"><a id="gab0fb576d41b10d5dea5641a244cca92b"></a>
template&lt;typename I , typename S , typename F , typename P  = identity&gt; </td></tr>
<tr class="memitem:gab0fb576d41b10d5dea5641a244cca92b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gab0fb576d41b10d5dea5641a244cca92b">ranges::all_of</a> (I first, S last, F pred, P proj=P{}) -&gt; bool requires input_iterator&lt; I &gt; &amp;&amp;sentinel_for&lt; S, I &gt; &amp;&amp;indirect_unary_predicate&lt; F, projected&lt; I, P &gt;&gt;</td></tr>
<tr class="memdesc:gab0fb576d41b10d5dea5641a244cca92b"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>all_of</code> <br /></td></tr>
<tr class="separator:gab0fb576d41b10d5dea5641a244cca92b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga264d1b1c80f6f675d5c708d9b044a7f0"><td class="memTemplParams" colspan="2">template&lt;typename Rng , typename F , typename P  = identity&gt; </td></tr>
<tr class="memitem:ga264d1b1c80f6f675d5c708d9b044a7f0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga264d1b1c80f6f675d5c708d9b044a7f0">ranges::all_of</a> (Rng &amp;&amp;rng, F pred, P proj=P{}) -&gt; bool requires input_range&lt; Rng &gt; &amp;&amp;indirect_unary_predicate&lt; F, projected&lt; iterator_t&lt; Rng &gt;, P &gt;&gt;</td></tr>
<tr class="separator:ga264d1b1c80f6f675d5c708d9b044a7f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga279ac588c4dac30d1bf061feaf6dac8a"><td class="memTemplParams" colspan="2"><a id="ga279ac588c4dac30d1bf061feaf6dac8a"></a>
template&lt;typename I , typename S , typename F , typename P  = identity&gt; </td></tr>
<tr class="memitem:ga279ac588c4dac30d1bf061feaf6dac8a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga279ac588c4dac30d1bf061feaf6dac8a">ranges::any_of</a> (I first, S last, F pred, P proj=P{}) -&gt; bool requires input_iterator&lt; I &gt; &amp;&amp;sentinel_for&lt; S, I &gt; &amp;&amp;indirect_unary_predicate&lt; F, projected&lt; I, P &gt;&gt;</td></tr>
<tr class="memdesc:ga279ac588c4dac30d1bf061feaf6dac8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>any_of</code> <br /></td></tr>
<tr class="separator:ga279ac588c4dac30d1bf061feaf6dac8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad75b386493da30a175489379ad3d44ed"><td class="memTemplParams" colspan="2">template&lt;typename Rng , typename F , typename P  = identity&gt; </td></tr>
<tr class="memitem:gad75b386493da30a175489379ad3d44ed"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gad75b386493da30a175489379ad3d44ed">ranges::any_of</a> (Rng &amp;&amp;rng, F pred, P proj=P{}) -&gt; bool requires input_range&lt; Rng &gt; &amp;&amp;indirect_unary_predicate&lt; F, projected&lt; iterator_t&lt; Rng &gt;, P &gt;&gt;</td></tr>
<tr class="separator:gad75b386493da30a175489379ad3d44ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga522f7ae248b5dbfd4bf958089c30368e"><td class="memTemplParams" colspan="2">template&lt;typename I , typename S , typename V , typename C  = less, typename P  = identity&gt; </td></tr>
<tr class="memitem:ga522f7ae248b5dbfd4bf958089c30368e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga522f7ae248b5dbfd4bf958089c30368e">ranges::binary_search</a> (I first, S last, V const &amp;val, C pred=C{}, P proj=P{}) -&gt; bool requires forward_iterator&lt; I &gt; &amp;&amp;sentinel_for&lt; S, I &gt; &amp;&amp;indirect_strict_weak_order&lt; C, V const *, projected&lt; I, P &gt;&gt;</td></tr>
<tr class="memdesc:ga522f7ae248b5dbfd4bf958089c30368e"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>binary_search</code>  <a href="group__group-algorithms.html#ga522f7ae248b5dbfd4bf958089c30368e">More...</a><br /></td></tr>
<tr class="separator:ga522f7ae248b5dbfd4bf958089c30368e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae4f24f78b0f07cb2deca6cb3f7b01bfc"><td class="memTemplParams" colspan="2">template&lt;typename Rng , typename V , typename C  = less, typename P  = identity&gt; </td></tr>
<tr class="memitem:gae4f24f78b0f07cb2deca6cb3f7b01bfc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gae4f24f78b0f07cb2deca6cb3f7b01bfc">ranges::binary_search</a> (Rng &amp;&amp;rng, V const &amp;val, C pred=C{}, P proj=P{}) -&gt; bool requires forward_range&lt; Rng &gt; &amp;&amp;indirect_strict_weak_order&lt; C, V const *, projected&lt; iterator_t&lt; Rng &gt;, P &gt;&gt;</td></tr>
<tr class="separator:gae4f24f78b0f07cb2deca6cb3f7b01bfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga20cc9a6f2eaf8f090470a5e87c7e8264"><td class="memTemplParams" colspan="2"><a id="ga20cc9a6f2eaf8f090470a5e87c7e8264"></a>
template&lt;typename I , typename S , typename T , typename P  = identity&gt; </td></tr>
<tr class="memitem:ga20cc9a6f2eaf8f090470a5e87c7e8264"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga20cc9a6f2eaf8f090470a5e87c7e8264">ranges::contains</a> (I first, S last, const T &amp;val, P proj={}) -&gt; bool requires input_iterator&lt; I &gt; &amp;&amp;sentinel_for&lt; S, I &gt; &amp;&amp;indirect_relation&lt; <a class="el" href="structranges_1_1equal__to.html">equal_to</a>, projected&lt; I, P &gt;, const T * &gt;</td></tr>
<tr class="memdesc:ga20cc9a6f2eaf8f090470a5e87c7e8264"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>contains</code> <br /></td></tr>
<tr class="separator:ga20cc9a6f2eaf8f090470a5e87c7e8264"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga01a62ccee18d1fec2e634bb3141e8582"><td class="memTemplParams" colspan="2">template&lt;typename Rng , typename T , typename P  = identity&gt; </td></tr>
<tr class="memitem:ga01a62ccee18d1fec2e634bb3141e8582"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga01a62ccee18d1fec2e634bb3141e8582">ranges::contains</a> (Rng &amp;&amp;rng, const T &amp;val, P proj={}) -&gt; bool requires input_range&lt; Rng &gt; &amp;&amp;indirect_relation&lt; <a class="el" href="structranges_1_1equal__to.html">equal_to</a>, projected&lt; iterator_t&lt; Rng &gt;, P &gt;, const T * &gt;</td></tr>
<tr class="separator:ga01a62ccee18d1fec2e634bb3141e8582"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83cdf5c653cd6f7b6d18deaab905cdd9"><td class="memTemplParams" colspan="2"><a id="ga83cdf5c653cd6f7b6d18deaab905cdd9"></a>
template&lt;typename I , typename S , typename O &gt; </td></tr>
<tr class="memitem:ga83cdf5c653cd6f7b6d18deaab905cdd9"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga83cdf5c653cd6f7b6d18deaab905cdd9">ranges::copy</a> (I first, S last, O out) -&gt; copy_result&lt; I, O &gt; requires input_iterator&lt; I &gt; &amp;&amp;sentinel_for&lt; S, I &gt; &amp;&amp;weakly_incrementable&lt; O &gt; &amp;&amp;indirectly_copyable&lt; I, O &gt;</td></tr>
<tr class="memdesc:ga83cdf5c653cd6f7b6d18deaab905cdd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>copy</code> <br /></td></tr>
<tr class="separator:ga83cdf5c653cd6f7b6d18deaab905cdd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga917adb24d7ee65882cf576a5a4c5228d"><td class="memTemplParams" colspan="2">template&lt;typename Rng , typename O &gt; </td></tr>
<tr class="memitem:ga917adb24d7ee65882cf576a5a4c5228d"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga917adb24d7ee65882cf576a5a4c5228d">ranges::copy</a> (Rng &amp;&amp;rng, O out) -&gt; copy_result&lt; safe_iterator_t&lt; Rng &gt;, O &gt; requires input_range&lt; Rng &gt; &amp;&amp;weakly_incrementable&lt; O &gt; &amp;&amp;indirectly_copyable&lt; iterator_t&lt; Rng &gt;, O &gt;</td></tr>
<tr class="separator:ga917adb24d7ee65882cf576a5a4c5228d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1440e2b669271bb83e34324338757caf"><td class="memTemplParams" colspan="2"><a id="ga1440e2b669271bb83e34324338757caf"></a>
template&lt;typename I , typename S , typename O &gt; </td></tr>
<tr class="memitem:ga1440e2b669271bb83e34324338757caf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga1440e2b669271bb83e34324338757caf">ranges::copy_backward</a> (I first, S end_, O out) -&gt; copy_backward_result&lt; I, O &gt; requires bidirectional_iterator&lt; I &gt; &amp;&amp;sentinel_for&lt; S, I &gt; &amp;&amp;bidirectional_iterator&lt; O &gt; &amp;&amp;indirectly_copyable&lt; I, O &gt;</td></tr>
<tr class="memdesc:ga1440e2b669271bb83e34324338757caf"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>copy_backward</code> <br /></td></tr>
<tr class="separator:ga1440e2b669271bb83e34324338757caf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga908b242ebc91d53a3f38ce24d01493b1"><td class="memTemplParams" colspan="2">template&lt;typename Rng , typename O &gt; </td></tr>
<tr class="memitem:ga908b242ebc91d53a3f38ce24d01493b1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga908b242ebc91d53a3f38ce24d01493b1">ranges::copy_backward</a> (Rng &amp;&amp;rng, O out) -&gt; copy_backward_result&lt; safe_iterator_t&lt; Rng &gt;, O &gt; requires bidirectional_range&lt; Rng &gt; &amp;&amp;bidirectional_iterator&lt; O &gt; &amp;&amp;indirectly_copyable&lt; iterator_t&lt; Rng &gt;, O &gt;</td></tr>
<tr class="separator:ga908b242ebc91d53a3f38ce24d01493b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c7793e127e9f16451b8e2869ca8be78"><td class="memTemplParams" colspan="2"><a id="ga9c7793e127e9f16451b8e2869ca8be78"></a>
template&lt;typename I , typename S , typename O , typename F , typename P  = identity&gt; </td></tr>
<tr class="memitem:ga9c7793e127e9f16451b8e2869ca8be78"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga9c7793e127e9f16451b8e2869ca8be78">ranges::copy_if</a> (I first, S last, O out, F pred, P proj=P{}) -&gt; copy_if_result&lt; I, O &gt; requires input_iterator&lt; I &gt; &amp;&amp;sentinel_for&lt; S, I &gt; &amp;&amp;weakly_incrementable&lt; O &gt; &amp;&amp;indirect_unary_predicate&lt; F, projected&lt; I, P &gt;&gt; &amp;&amp;indirectly_copyable&lt; I, O &gt;</td></tr>
<tr class="memdesc:ga9c7793e127e9f16451b8e2869ca8be78"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>copy_if</code> <br /></td></tr>
<tr class="separator:ga9c7793e127e9f16451b8e2869ca8be78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf2c0297eeb25e9a6fd9d1323f4eb967"><td class="memTemplParams" colspan="2">template&lt;typename Rng , typename O , typename F , typename P  = identity&gt; </td></tr>
<tr class="memitem:gacf2c0297eeb25e9a6fd9d1323f4eb967"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gacf2c0297eeb25e9a6fd9d1323f4eb967">ranges::copy_if</a> (Rng &amp;&amp;rng, O out, F pred, P proj=P{}) -&gt; copy_if_result&lt; safe_iterator_t&lt; Rng &gt;, O &gt; requires input_range&lt; Rng &gt; &amp;&amp;weakly_incrementable&lt; O &gt; &amp;&amp;indirect_unary_predicate&lt; F, projected&lt; iterator_t&lt; Rng &gt;, P &gt;&gt; &amp;&amp;indirectly_copyable&lt; iterator_t&lt; Rng &gt;, O &gt;</td></tr>
<tr class="separator:gacf2c0297eeb25e9a6fd9d1323f4eb967"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5dfbdb6265d19283095c021a2891bc5d"><td class="memTemplParams" colspan="2"><a id="ga5dfbdb6265d19283095c021a2891bc5d"></a>
template&lt;typename I , typename O , typename P  = identity&gt; </td></tr>
<tr class="memitem:ga5dfbdb6265d19283095c021a2891bc5d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga5dfbdb6265d19283095c021a2891bc5d">ranges::copy_n</a> (I first, iter_difference_t&lt; I &gt; n, O out) -&gt; copy_n_result&lt; I, O &gt; requires input_iterator&lt; I &gt; &amp;&amp;weakly_incrementable&lt; O &gt; &amp;&amp;indirectly_copyable&lt; I, O &gt;</td></tr>
<tr class="memdesc:ga5dfbdb6265d19283095c021a2891bc5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>copy_n</code> <br /></td></tr>
<tr class="separator:ga5dfbdb6265d19283095c021a2891bc5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a6302f276cdf98372e30f45d10ae3a4"><td class="memTemplParams" colspan="2"><a id="ga0a6302f276cdf98372e30f45d10ae3a4"></a>
template&lt;typename I , typename S , typename V , typename P  = identity&gt; </td></tr>
<tr class="memitem:ga0a6302f276cdf98372e30f45d10ae3a4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga0a6302f276cdf98372e30f45d10ae3a4">ranges::count</a> (I first, S last, V const &amp;val, P proj=P{}) -&gt; iter_difference_t&lt; I &gt; requires input_iterator&lt; I &gt; &amp;&amp;sentinel_for&lt; S, I &gt; &amp;&amp;indirect_relation&lt; <a class="el" href="structranges_1_1equal__to.html">equal_to</a>, projected&lt; I, P &gt;, V const * &gt;</td></tr>
<tr class="memdesc:ga0a6302f276cdf98372e30f45d10ae3a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>count</code> <br /></td></tr>
<tr class="separator:ga0a6302f276cdf98372e30f45d10ae3a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2ef1075d6f1f102246b50dff5e01eda"><td class="memTemplParams" colspan="2">template&lt;typename Rng , typename V , typename P  = identity&gt; </td></tr>
<tr class="memitem:gae2ef1075d6f1f102246b50dff5e01eda"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gae2ef1075d6f1f102246b50dff5e01eda">ranges::count</a> (Rng &amp;&amp;rng, V const &amp;val, P proj=P{}) -&gt; iter_difference_t&lt; iterator_t&lt; Rng &gt;&gt; requires input_range&lt; Rng &gt; &amp;&amp;indirect_relation&lt; <a class="el" href="structranges_1_1equal__to.html">equal_to</a>, projected&lt; iterator_t&lt; Rng &gt;, P &gt;, V const * &gt;</td></tr>
<tr class="separator:gae2ef1075d6f1f102246b50dff5e01eda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa6d7932d258fee27a78a08afefdeda1b"><td class="memTemplParams" colspan="2"><a id="gaa6d7932d258fee27a78a08afefdeda1b"></a>
template&lt;typename I , typename S , typename R , typename P  = identity&gt; </td></tr>
<tr class="memitem:gaa6d7932d258fee27a78a08afefdeda1b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gaa6d7932d258fee27a78a08afefdeda1b">ranges::count_if</a> (I first, S last, R pred, P proj=P{}) -&gt; iter_difference_t&lt; I &gt; requires input_iterator&lt; I &gt; &amp;&amp;sentinel_for&lt; S, I &gt; &amp;&amp;indirect_unary_predicate&lt; R, projected&lt; I, P &gt;&gt;</td></tr>
<tr class="memdesc:gaa6d7932d258fee27a78a08afefdeda1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>count_if</code> <br /></td></tr>
<tr class="separator:gaa6d7932d258fee27a78a08afefdeda1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a066f39ca76bf1389b93ffd55720f7e"><td class="memTemplParams" colspan="2">template&lt;typename Rng , typename R , typename P  = identity&gt; </td></tr>
<tr class="memitem:ga8a066f39ca76bf1389b93ffd55720f7e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga8a066f39ca76bf1389b93ffd55720f7e">ranges::count_if</a> (Rng &amp;&amp;rng, R pred, P proj=P{}) -&gt; iter_difference_t&lt; iterator_t&lt; Rng &gt;&gt; requires input_range&lt; Rng &gt; &amp;&amp;indirect_unary_predicate&lt; R, projected&lt; iterator_t&lt; Rng &gt;, P &gt;&gt;</td></tr>
<tr class="separator:ga8a066f39ca76bf1389b93ffd55720f7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c871db78e32e35d5e77d844f2df9bd6"><td class="memTemplParams" colspan="2"><a id="ga1c871db78e32e35d5e77d844f2df9bd6"></a>
template&lt;typename I0 , typename S0 , typename I1 , typename S1 , typename C  = equal_to, typename P0  = identity, typename P1  = identity&gt; </td></tr>
<tr class="memitem:ga1c871db78e32e35d5e77d844f2df9bd6"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga1c871db78e32e35d5e77d844f2df9bd6">ranges::ends_with</a> (I0 begin0, S0 end0, I1 begin1, S1 end1, C pred=C{}, P0 proj0=P0{}, P1 proj1=P1{}) -&gt; bool requires((forward_iterator&lt; I0 &gt; &amp;&amp;sentinel_for&lt; S0, I0 &gt;)||(input_iterator&lt; I0 &gt; &amp;&amp;sized_sentinel_for&lt; S0, I0 &gt;)) &amp;&amp;((forward_iterator&lt; I1 &gt; &amp;&amp;sentinel_for&lt; S1, I1 &gt;)||(input_iterator&lt; I1 &gt; &amp;&amp;sized_sentinel_for&lt; S1, I1 &gt;)) &amp;&amp;indirectly_comparable&lt; I0, I1, C, P0, P1 &gt;</td></tr>
<tr class="memdesc:ga1c871db78e32e35d5e77d844f2df9bd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>ends_with</code> <br /></td></tr>
<tr class="separator:ga1c871db78e32e35d5e77d844f2df9bd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga153b08aa10efdd1745b55a66dff7aa65"><td class="memTemplParams" colspan="2">template&lt;typename Rng0 , typename Rng1 , typename C  = equal_to, typename P0  = identity, typename P1  = identity&gt; </td></tr>
<tr class="memitem:ga153b08aa10efdd1745b55a66dff7aa65"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga153b08aa10efdd1745b55a66dff7aa65">ranges::ends_with</a> (Rng0 &amp;&amp;rng0, Rng1 &amp;&amp;rng1, C pred=C{}, P0 proj0=P0{}, P1 proj1=P1{}) -&gt; bool requires(forward_range&lt; Rng0 &gt;||(input_range&lt; Rng0 &gt; &amp;&amp;sized_range&lt; Rng0 &gt;)) &amp;&amp;(forward_range&lt; Rng1 &gt;||(input_range&lt; Rng1 &gt; &amp;&amp;sized_range&lt; Rng1 &gt;)) &amp;&amp;indirectly_comparable&lt; iterator_t&lt; Rng0 &gt;, iterator_t&lt; Rng1 &gt;, C, P0, P1 &gt;</td></tr>
<tr class="separator:ga153b08aa10efdd1745b55a66dff7aa65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62f56efe45b73d94db6a81f40e12d1b9"><td class="memTemplParams" colspan="2"><a id="ga62f56efe45b73d94db6a81f40e12d1b9"></a>
template&lt;typename I0 , typename S0 , typename I1 , typename C  = equal_to, typename P0  = identity, typename P1  = identity&gt; </td></tr>
<tr class="memitem:ga62f56efe45b73d94db6a81f40e12d1b9"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga62f56efe45b73d94db6a81f40e12d1b9">ranges::equal</a> (I0 begin0, S0 end0, I1 begin1, C pred=C{}, P0 proj0=P0{}, P1 proj1=P1{}) -&gt; bool requires input_iterator&lt; I0 &gt; &amp;&amp;sentinel_for&lt; S0, I0 &gt; &amp;&amp;input_iterator&lt; I1 &gt; &amp;&amp;indirectly_comparable&lt; I0, I1, C, P0, P1 &gt;</td></tr>
<tr class="memdesc:ga62f56efe45b73d94db6a81f40e12d1b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>equal</code> <br /></td></tr>
<tr class="separator:ga62f56efe45b73d94db6a81f40e12d1b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf7135f2a482e12c3d97d77c3e13937eb"><td class="memTemplParams" colspan="2">template&lt;typename I0 , typename S0 , typename I1 , typename S1 , typename C  = equal_to, typename P0  = identity, typename P1  = identity&gt; </td></tr>
<tr class="memitem:gaf7135f2a482e12c3d97d77c3e13937eb"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gaf7135f2a482e12c3d97d77c3e13937eb">ranges::equal</a> (I0 begin0, S0 end0, I1 begin1, S1 end1, C pred=C{}, P0 proj0=P0{}, P1 proj1=P1{}) -&gt; bool requires input_iterator&lt; I0 &gt; &amp;&amp;sentinel_for&lt; S0, I0 &gt; &amp;&amp;input_iterator&lt; I1 &gt; &amp;&amp;sentinel_for&lt; S1, I1 &gt; &amp;&amp;indirectly_comparable&lt; I0, I1, C, P0, P1 &gt;</td></tr>
<tr class="separator:gaf7135f2a482e12c3d97d77c3e13937eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4bb144928dd7fc7c4004bde7b8b5240e"><td class="memTemplParams" colspan="2">template&lt;typename Rng0 , typename I1Ref , typename C  = equal_to, typename P0  = identity, typename P1  = identity&gt; </td></tr>
<tr class="memitem:ga4bb144928dd7fc7c4004bde7b8b5240e"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga4bb144928dd7fc7c4004bde7b8b5240e">ranges::equal</a> (Rng0 &amp;&amp;rng0, I1Ref &amp;&amp;begin1, C pred=C{}, P0 proj0=P0{}, P1 proj1=P1{}) -&gt; bool requires input_range&lt; Rng0 &gt; &amp;&amp;input_iterator&lt; uncvref_t&lt; I1Ref &gt;&gt; &amp;&amp;indirectly_comparable&lt; iterator_t&lt; Rng0 &gt;, uncvref_t&lt; I1Ref &gt;, C, P0, P1 &gt;</td></tr>
<tr class="separator:ga4bb144928dd7fc7c4004bde7b8b5240e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd9f750063e371826d0d82e81c5d825e"><td class="memTemplParams" colspan="2">template&lt;typename Rng0 , typename Rng1 , typename C  = equal_to, typename P0  = identity, typename P1  = identity&gt; </td></tr>
<tr class="memitem:gacd9f750063e371826d0d82e81c5d825e"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gacd9f750063e371826d0d82e81c5d825e">ranges::equal</a> (Rng0 &amp;&amp;rng0, Rng1 &amp;&amp;rng1, C pred=C{}, P0 proj0=P0{}, P1 proj1=P1{}) -&gt; bool requires input_range&lt; Rng0 &gt; &amp;&amp;input_range&lt; Rng1 &gt; &amp;&amp;indirectly_comparable&lt; iterator_t&lt; Rng0 &gt;, iterator_t&lt; Rng1 &gt;, C, P0, P1 &gt;</td></tr>
<tr class="separator:gacd9f750063e371826d0d82e81c5d825e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e5ccafe6cf7b68fa9b042d550c1396e"><td class="memTemplParams" colspan="2"><a id="ga0e5ccafe6cf7b68fa9b042d550c1396e"></a>
template&lt;typename I , typename S , typename V , typename C  = less, typename P  = identity&gt; </td></tr>
<tr class="memitem:ga0e5ccafe6cf7b68fa9b042d550c1396e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga0e5ccafe6cf7b68fa9b042d550c1396e">ranges::equal_range</a> (I first, S last, V const &amp;val, C pred=C{}, P proj=P{}) -&gt; <a class="el" href="structranges_1_1subrange.html">subrange</a>&lt; I &gt; requires forward_iterator&lt; I &gt; &amp;&amp;sentinel_for&lt; S, I &gt; &amp;&amp;indirect_strict_weak_order&lt; C, V const *, projected&lt; I, P &gt;&gt;</td></tr>
<tr class="memdesc:ga0e5ccafe6cf7b68fa9b042d550c1396e"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>equal_range</code> <br /></td></tr>
<tr class="separator:ga0e5ccafe6cf7b68fa9b042d550c1396e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab6bb9cf9ee4851960191848e5fc1a34e"><td class="memTemplParams" colspan="2">template&lt;typename Rng , typename V , typename C  = less, typename P  = identity&gt; </td></tr>
<tr class="memitem:gab6bb9cf9ee4851960191848e5fc1a34e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gab6bb9cf9ee4851960191848e5fc1a34e">ranges::equal_range</a> (Rng &amp;&amp;rng, V const &amp;val, C pred=C{}, P proj=P{}) -&gt; safe_subrange_t&lt; Rng &gt; requires forward_range&lt; Rng &gt; &amp;&amp;indirect_strict_weak_order&lt; C, V const *, projected&lt; iterator_t&lt; Rng &gt;, P &gt;&gt;</td></tr>
<tr class="separator:gab6bb9cf9ee4851960191848e5fc1a34e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9d5c547eca91958d6a9c63233c5f4b1"><td class="memTemplParams" colspan="2"><a id="gae9d5c547eca91958d6a9c63233c5f4b1"></a>
template&lt;typename O , typename S , typename V &gt; </td></tr>
<tr class="memitem:gae9d5c547eca91958d6a9c63233c5f4b1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gae9d5c547eca91958d6a9c63233c5f4b1">ranges::fill</a> (O first, S last, V const &amp;val) -&gt; O requires output_iterator&lt; O, V const &amp; &gt; &amp;&amp;sentinel_for&lt; S, O &gt;</td></tr>
<tr class="memdesc:gae9d5c547eca91958d6a9c63233c5f4b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>fill</code> <br /></td></tr>
<tr class="separator:gae9d5c547eca91958d6a9c63233c5f4b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1250c1c363e349a985a2b3b89a31f7fa"><td class="memTemplParams" colspan="2">template&lt;typename Rng , typename V &gt; </td></tr>
<tr class="memitem:ga1250c1c363e349a985a2b3b89a31f7fa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga1250c1c363e349a985a2b3b89a31f7fa">ranges::fill</a> (Rng &amp;&amp;rng, V const &amp;val) -&gt; safe_iterator_t&lt; Rng &gt; requires output_range&lt; Rng, V const &amp; &gt;</td></tr>
<tr class="separator:ga1250c1c363e349a985a2b3b89a31f7fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a85315279234ac2155d2e351f7df0e2"><td class="memTemplParams" colspan="2"><a id="ga8a85315279234ac2155d2e351f7df0e2"></a>
template&lt;typename O , typename V &gt; </td></tr>
<tr class="memitem:ga8a85315279234ac2155d2e351f7df0e2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga8a85315279234ac2155d2e351f7df0e2">ranges::fill_n</a> (O first, iter_difference_t&lt; O &gt; n, V const &amp;val) -&gt; O requires output_iterator&lt; O, V const &amp; &gt;</td></tr>
<tr class="memdesc:ga8a85315279234ac2155d2e351f7df0e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>equal</code> <br /></td></tr>
<tr class="separator:ga8a85315279234ac2155d2e351f7df0e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0c8dbb38d3d49a554898eea469baee7"><td class="memTemplParams" colspan="2">template&lt;typename I , typename S , typename V , typename P  = identity&gt; </td></tr>
<tr class="memitem:gaa0c8dbb38d3d49a554898eea469baee7"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gaa0c8dbb38d3d49a554898eea469baee7">ranges::find</a> (I first, S last, V const &amp;val, P proj=P{}) -&gt; I requires input_iterator&lt; I &gt; &amp;&amp;sentinel_for&lt; S, I &gt; &amp;&amp;indirect_relation&lt; <a class="el" href="structranges_1_1equal__to.html">equal_to</a>, projected&lt; I, P &gt;, V const * &gt;</td></tr>
<tr class="memdesc:gaa0c8dbb38d3d49a554898eea469baee7"><td class="mdescLeft">&#160;</td><td class="mdescRight">template function <code>find</code>  <a href="group__group-algorithms.html#gaa0c8dbb38d3d49a554898eea469baee7">More...</a><br /></td></tr>
<tr class="separator:gaa0c8dbb38d3d49a554898eea469baee7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1fdffc553245eb3c303eaff6e178bf70"><td class="memTemplParams" colspan="2">template&lt;typename Rng , typename V , typename P  = identity&gt; </td></tr>
<tr class="memitem:ga1fdffc553245eb3c303eaff6e178bf70"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga1fdffc553245eb3c303eaff6e178bf70">ranges::find</a> (Rng &amp;&amp;rng, V const &amp;val, P proj=P{}) -&gt; safe_iterator_t&lt; Rng &gt; requires input_range&lt; Rng &gt; &amp;&amp;indirect_relation&lt; <a class="el" href="structranges_1_1equal__to.html">equal_to</a>, projected&lt; iterator_t&lt; Rng &gt;, P &gt;, V const * &gt;</td></tr>
<tr class="separator:ga1fdffc553245eb3c303eaff6e178bf70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe2b55fa404c2670cce8f3441d3b1485"><td class="memTemplParams" colspan="2"><a id="gafe2b55fa404c2670cce8f3441d3b1485"></a>
template&lt;typename I1 , typename S1 , typename I2 , typename S2 , typename R  = equal_to, typename P  = identity&gt; </td></tr>
<tr class="memitem:gafe2b55fa404c2670cce8f3441d3b1485"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gafe2b55fa404c2670cce8f3441d3b1485">ranges::find_end</a> (I1 begin1, S1 end1, I2 begin2, S2 end2, R pred=R{}, P proj=P{}) -&gt; <a class="el" href="structranges_1_1subrange.html">subrange</a>&lt; I1 &gt; requires forward_iterator&lt; I1 &gt; &amp;&amp;sentinel_for&lt; S1, I1 &gt; &amp;&amp;forward_iterator&lt; I2 &gt; &amp;&amp;sentinel_for&lt; S2, I2 &gt; &amp;&amp;indirect_relation&lt; R, projected&lt; I1, P &gt;, I2 &gt;</td></tr>
<tr class="memdesc:gafe2b55fa404c2670cce8f3441d3b1485"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>find_end</code> <br /></td></tr>
<tr class="separator:gafe2b55fa404c2670cce8f3441d3b1485"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab12f25e857f8d8468ec5955b4956f503"><td class="memTemplParams" colspan="2">template&lt;typename Rng1 , typename Rng2 , typename R  = equal_to, typename P  = identity&gt; </td></tr>
<tr class="memitem:gab12f25e857f8d8468ec5955b4956f503"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gab12f25e857f8d8468ec5955b4956f503">ranges::find_end</a> (Rng1 &amp;&amp;rng1, Rng2 &amp;&amp;rng2, R pred=R{}, P proj=P{}) -&gt; safe_subrange_t&lt; Rng1 &gt; requires forward_range&lt; Rng1 &gt; &amp;&amp;forward_range&lt; Rng2 &gt; &amp;&amp;indirect_relation&lt; R, projected&lt; iterator_t&lt; Rng1 &gt;, P &gt;, iterator_t&lt; Rng2 &gt;&gt;</td></tr>
<tr class="separator:gab12f25e857f8d8468ec5955b4956f503"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf8db82c6ebdcf9be833020f9efebcad6"><td class="memTemplParams" colspan="2"><a id="gaf8db82c6ebdcf9be833020f9efebcad6"></a>
template&lt;typename I0 , typename S0 , typename I1 , typename S1 , typename R  = equal_to, typename P0  = identity, typename P1  = identity&gt; </td></tr>
<tr class="memitem:gaf8db82c6ebdcf9be833020f9efebcad6"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gaf8db82c6ebdcf9be833020f9efebcad6">ranges::find_first_of</a> (I0 begin0, S0 end0, I1 begin1, S1 end1, R pred=R{}, P0 proj0=P0{}, P1 proj1=P1{}) -&gt; I0 requires input_iterator&lt; I0 &gt; &amp;&amp;sentinel_for&lt; S0, I0 &gt; &amp;&amp;forward_iterator&lt; I1 &gt; &amp;&amp;sentinel_for&lt; S1, I1 &gt; &amp;&amp;indirect_relation&lt; R, projected&lt; I0, P0 &gt;, projected&lt; I1, P1 &gt;&gt;</td></tr>
<tr class="memdesc:gaf8db82c6ebdcf9be833020f9efebcad6"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>find_first_of</code> <br /></td></tr>
<tr class="separator:gaf8db82c6ebdcf9be833020f9efebcad6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12a7a0c47e8ee9b4a4448ff7de8d7a8b"><td class="memTemplParams" colspan="2">template&lt;typename Rng0 , typename Rng1 , typename R  = equal_to, typename P0  = identity, typename P1  = identity&gt; </td></tr>
<tr class="memitem:ga12a7a0c47e8ee9b4a4448ff7de8d7a8b"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga12a7a0c47e8ee9b4a4448ff7de8d7a8b">ranges::find_first_of</a> (Rng0 &amp;&amp;rng0, Rng1 &amp;&amp;rng1, R pred=R{}, P0 proj0=P0{}, P1 proj1=P1{}) -&gt; safe_iterator_t&lt; Rng0 &gt; requires input_range&lt; Rng0 &gt; &amp;&amp;forward_range&lt; Rng1 &gt; &amp;&amp;indirect_relation&lt; R, projected&lt; iterator_t&lt; Rng0 &gt;, P0 &gt;, projected&lt; iterator_t&lt; Rng1 &gt;, P1 &gt;&gt;</td></tr>
<tr class="separator:ga12a7a0c47e8ee9b4a4448ff7de8d7a8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97d40229d9524a2dca7bdfa1dc41eb7f"><td class="memTemplParams" colspan="2">template&lt;typename I , typename S , typename F , typename P  = identity&gt; </td></tr>
<tr class="memitem:ga97d40229d9524a2dca7bdfa1dc41eb7f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga97d40229d9524a2dca7bdfa1dc41eb7f">ranges::find_if</a> (I first, S last, F pred, P proj=P{}) -&gt; I requires input_iterator&lt; I &gt; &amp;&amp;sentinel_for&lt; S, I &gt; &amp;&amp;indirect_unary_predicate&lt; F, projected&lt; I, P &gt;&gt;</td></tr>
<tr class="memdesc:ga97d40229d9524a2dca7bdfa1dc41eb7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">template function <code>find</code>  <a href="group__group-algorithms.html#ga97d40229d9524a2dca7bdfa1dc41eb7f">More...</a><br /></td></tr>
<tr class="separator:ga97d40229d9524a2dca7bdfa1dc41eb7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83655c30e620ed517ebd2f6ea039f84b"><td class="memTemplParams" colspan="2">template&lt;typename Rng , typename F , typename P  = identity&gt; </td></tr>
<tr class="memitem:ga83655c30e620ed517ebd2f6ea039f84b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga83655c30e620ed517ebd2f6ea039f84b">ranges::find_if</a> (Rng &amp;&amp;rng, F pred, P proj=P{}) -&gt; safe_iterator_t&lt; Rng &gt; requires input_range&lt; Rng &gt; &amp;&amp;indirect_unary_predicate&lt; F, projected&lt; iterator_t&lt; Rng &gt;, P &gt;&gt;</td></tr>
<tr class="separator:ga83655c30e620ed517ebd2f6ea039f84b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5baa6a43c9610670e8256e4ee4b9eb1"><td class="memTemplParams" colspan="2">template&lt;typename I , typename S , typename F , typename P  = identity&gt; </td></tr>
<tr class="memitem:gad5baa6a43c9610670e8256e4ee4b9eb1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gad5baa6a43c9610670e8256e4ee4b9eb1">ranges::find_if_not</a> (I first, S last, F pred, P proj=P{}) -&gt; I requires input_iterator&lt; I &gt; &amp;&amp;sentinel_for&lt; S, I &gt; &amp;&amp;indirect_unary_predicate&lt; F, projected&lt; I, P &gt;&gt;</td></tr>
<tr class="memdesc:gad5baa6a43c9610670e8256e4ee4b9eb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">template function <code>find_if_not</code>  <a href="group__group-algorithms.html#gad5baa6a43c9610670e8256e4ee4b9eb1">More...</a><br /></td></tr>
<tr class="separator:gad5baa6a43c9610670e8256e4ee4b9eb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7017c275cc667040bcbd35f568571f11"><td class="memTemplParams" colspan="2">template&lt;typename Rng , typename F , typename P  = identity&gt; </td></tr>
<tr class="memitem:ga7017c275cc667040bcbd35f568571f11"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga7017c275cc667040bcbd35f568571f11">ranges::find_if_not</a> (Rng &amp;&amp;rng, F pred, P proj=P{}) -&gt; safe_iterator_t&lt; Rng &gt; requires input_range&lt; Rng &gt; &amp;&amp;indirect_unary_predicate&lt; F, projected&lt; iterator_t&lt; Rng &gt;, P &gt;&gt;</td></tr>
<tr class="separator:ga7017c275cc667040bcbd35f568571f11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5148d309f477cd1ab91e7a7b5d933046"><td class="memTemplParams" colspan="2"><a id="ga5148d309f477cd1ab91e7a7b5d933046"></a>
template&lt;typename I , typename S , typename F , typename P  = identity&gt; </td></tr>
<tr class="memitem:ga5148d309f477cd1ab91e7a7b5d933046"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga5148d309f477cd1ab91e7a7b5d933046">ranges::for_each</a> (I first, S last, F fun, P proj=P{}) -&gt; for_each_result&lt; I, F &gt; requires input_iterator&lt; I &gt; &amp;&amp;sentinel_for&lt; S, I &gt; &amp;&amp;indirectly_unary_invocable&lt; F, projected&lt; I, P &gt;&gt;</td></tr>
<tr class="memdesc:ga5148d309f477cd1ab91e7a7b5d933046"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>for_each</code> <br /></td></tr>
<tr class="separator:ga5148d309f477cd1ab91e7a7b5d933046"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa213bfef81a971e1523c4510112de5e4"><td class="memTemplParams" colspan="2">template&lt;typename Rng , typename F , typename P  = identity&gt; </td></tr>
<tr class="memitem:gaa213bfef81a971e1523c4510112de5e4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gaa213bfef81a971e1523c4510112de5e4">ranges::for_each</a> (Rng &amp;&amp;rng, F fun, P proj=P{}) -&gt; for_each_result&lt; safe_iterator_t&lt; Rng &gt;, F &gt; requires input_range&lt; Rng &gt; &amp;&amp;indirectly_unary_invocable&lt; F, projected&lt; iterator_t&lt; Rng &gt;, P &gt;&gt;</td></tr>
<tr class="separator:gaa213bfef81a971e1523c4510112de5e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad07cd5e802ad4dacdce09794a243ece2"><td class="memTemplParams" colspan="2"><a id="gad07cd5e802ad4dacdce09794a243ece2"></a>
template&lt;typename I , typename F , typename P  = identity&gt; </td></tr>
<tr class="memitem:gad07cd5e802ad4dacdce09794a243ece2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gad07cd5e802ad4dacdce09794a243ece2">ranges::for_each_n</a> (I first, iter_difference_t&lt; I &gt; n, F fun, P proj=P{}) -&gt; I requires input_iterator&lt; I &gt; &amp;&amp;indirectly_unary_invocable&lt; F, projected&lt; I, P &gt;&gt;</td></tr>
<tr class="memdesc:gad07cd5e802ad4dacdce09794a243ece2"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>for_each_n</code> <br /></td></tr>
<tr class="separator:gad07cd5e802ad4dacdce09794a243ece2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae8bf0c761837f2a0fb513a6bfee8db26"><td class="memTemplParams" colspan="2">template&lt;typename Rng , typename F , typename P  = identity&gt; </td></tr>
<tr class="memitem:gae8bf0c761837f2a0fb513a6bfee8db26"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gae8bf0c761837f2a0fb513a6bfee8db26">ranges::for_each_n</a> (Rng &amp;&amp;rng, range_difference_t&lt; Rng &gt; n, F fun, P proj=P{}) -&gt; safe_iterator_t&lt; Rng &gt; requires input_range&lt; Rng &gt; &amp;&amp;indirectly_unary_invocable&lt; F, projected&lt; iterator_t&lt; Rng &gt;, P &gt;&gt;</td></tr>
<tr class="separator:gae8bf0c761837f2a0fb513a6bfee8db26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1218fcda185e3cbfa06c8da79062bba4"><td class="memTemplParams" colspan="2"><a id="ga1218fcda185e3cbfa06c8da79062bba4"></a>
template&lt;typename O , typename S , typename F &gt; </td></tr>
<tr class="memitem:ga1218fcda185e3cbfa06c8da79062bba4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga1218fcda185e3cbfa06c8da79062bba4">ranges::generate</a> (O first, S last, F fun) -&gt; generate_result&lt; O, F &gt; requires invocable&lt; F &amp; &gt; &amp;&amp;output_iterator&lt; O, invoke_result_t&lt; F &amp; &gt;&gt; &amp;&amp;sentinel_for&lt; S, O &gt;</td></tr>
<tr class="memdesc:ga1218fcda185e3cbfa06c8da79062bba4"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>generate_n</code> <br /></td></tr>
<tr class="separator:ga1218fcda185e3cbfa06c8da79062bba4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae277dfff0628b1e0f057d81ad801db10"><td class="memTemplParams" colspan="2">template&lt;typename Rng , typename F &gt; </td></tr>
<tr class="memitem:gae277dfff0628b1e0f057d81ad801db10"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gae277dfff0628b1e0f057d81ad801db10">ranges::generate</a> (Rng &amp;&amp;rng, F fun) -&gt; generate_result&lt; safe_iterator_t&lt; Rng &gt;, F &gt; requires invocable&lt; F &amp; &gt; &amp;&amp;output_range&lt; Rng, invoke_result_t&lt; F &amp; &gt;&gt;</td></tr>
<tr class="separator:gae277dfff0628b1e0f057d81ad801db10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga608800721885fcd293a8937fe4947194"><td class="memTemplParams" colspan="2"><a id="ga608800721885fcd293a8937fe4947194"></a>
template&lt;typename O , typename F &gt; </td></tr>
<tr class="memitem:ga608800721885fcd293a8937fe4947194"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga608800721885fcd293a8937fe4947194">ranges::generate_n</a> (O first, iter_difference_t&lt; O &gt; n, F fun) -&gt; generate_n_result&lt; O, F &gt; requires invocable&lt; F &amp; &gt; &amp;&amp;output_iterator&lt; O, invoke_result_t&lt; F &amp; &gt;&gt;</td></tr>
<tr class="memdesc:ga608800721885fcd293a8937fe4947194"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>generate_n</code> <br /></td></tr>
<tr class="separator:ga608800721885fcd293a8937fe4947194"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb425eb823af17dcbcbd2f60a227affe"><td class="memTemplParams" colspan="2"><a id="gaeb425eb823af17dcbcbd2f60a227affe"></a>
template&lt;typename I1 , typename S1 , typename I2 , typename S2 , typename C  = less, typename P1  = identity, typename P2  = identity&gt; </td></tr>
<tr class="memitem:gaeb425eb823af17dcbcbd2f60a227affe"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gaeb425eb823af17dcbcbd2f60a227affe">ranges::includes</a> (I1 begin1, S1 end1, I2 begin2, S2 end2, C pred=C{}, P1 proj1=P1{}, P2 proj2=P2{}) -&gt; bool requires input_iterator&lt; I1 &gt; &amp;&amp;sentinel_for&lt; S1, I1 &gt; &amp;&amp;input_iterator&lt; I2 &gt; &amp;&amp;sentinel_for&lt; S2, I2 &gt; &amp;&amp;indirect_strict_weak_order&lt; C, projected&lt; I1, P1 &gt;, projected&lt; I2, P2 &gt;&gt;</td></tr>
<tr class="memdesc:gaeb425eb823af17dcbcbd2f60a227affe"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>includes</code> <br /></td></tr>
<tr class="separator:gaeb425eb823af17dcbcbd2f60a227affe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad038da5f95761d60c391d925d81d7291"><td class="memTemplParams" colspan="2">template&lt;typename Rng1 , typename Rng2 , typename C  = less, typename P1  = identity, typename P2  = identity&gt; </td></tr>
<tr class="memitem:gad038da5f95761d60c391d925d81d7291"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gad038da5f95761d60c391d925d81d7291">ranges::includes</a> (Rng1 &amp;&amp;rng1, Rng2 &amp;&amp;rng2, C pred=C{}, P1 proj1=P1{}, P2 proj2=P2{}) -&gt; bool requires input_range&lt; Rng1 &gt; &amp;&amp;input_range&lt; Rng2 &gt; &amp;&amp;indirect_strict_weak_order&lt; C, projected&lt; iterator_t&lt; Rng1 &gt;, P1 &gt;, projected&lt; iterator_t&lt; Rng2 &gt;, P2 &gt;&gt;</td></tr>
<tr class="separator:gad038da5f95761d60c391d925d81d7291"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8716e95ad18cb12a55b05e53b5acc6d9"><td class="memTemplParams" colspan="2"><a id="ga8716e95ad18cb12a55b05e53b5acc6d9"></a>
template&lt;typename I , typename S , typename C  = less, typename P  = identity&gt; </td></tr>
<tr class="memitem:ga8716e95ad18cb12a55b05e53b5acc6d9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga8716e95ad18cb12a55b05e53b5acc6d9">ranges::inplace_merge</a> (I first, I middle, S last, C pred=C{}, P proj=P{}) -&gt; I requires bidirectional_iterator&lt; I &gt; &amp;&amp;sortable&lt; I, C, P &gt;</td></tr>
<tr class="memdesc:ga8716e95ad18cb12a55b05e53b5acc6d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>inplace_merge</code> <br /></td></tr>
<tr class="separator:ga8716e95ad18cb12a55b05e53b5acc6d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafff3693db2a1593b6f7f6997466e5906"><td class="memTemplParams" colspan="2">template&lt;typename Rng , typename C  = less, typename P  = identity&gt; </td></tr>
<tr class="memitem:gafff3693db2a1593b6f7f6997466e5906"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gafff3693db2a1593b6f7f6997466e5906">ranges::inplace_merge</a> (Rng &amp;&amp;rng, iterator_t&lt; Rng &gt; middle, C pred=C{}, P proj=P{}) -&gt; safe_iterator_t&lt; Rng &gt; requires bidirectional_range&lt; Rng &gt; &amp;&amp;sortable&lt; iterator_t&lt; Rng &gt;, C, P &gt;</td></tr>
<tr class="separator:gafff3693db2a1593b6f7f6997466e5906"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad21d5a0e84bb91c343af042fb73332cd"><td class="memTemplParams" colspan="2"><a id="gad21d5a0e84bb91c343af042fb73332cd"></a>
template&lt;typename I , typename S , typename C  = less, typename P  = identity&gt; </td></tr>
<tr class="memitem:gad21d5a0e84bb91c343af042fb73332cd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gad21d5a0e84bb91c343af042fb73332cd">ranges::is_heap</a> (I first, S last, C pred=C{}, P proj=P{}) -&gt; bool requires random_access_iterator&lt; I &gt; &amp;&amp;sentinel_for&lt; S, I &gt; &amp;&amp;indirect_strict_weak_order&lt; C, projected&lt; I, P &gt;&gt;</td></tr>
<tr class="memdesc:gad21d5a0e84bb91c343af042fb73332cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>is_heap</code> <br /></td></tr>
<tr class="separator:gad21d5a0e84bb91c343af042fb73332cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga650418789a5ddc477e26fad6fe7f0fb2"><td class="memTemplParams" colspan="2">template&lt;typename Rng , typename C  = less, typename P  = identity&gt; </td></tr>
<tr class="memitem:ga650418789a5ddc477e26fad6fe7f0fb2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga650418789a5ddc477e26fad6fe7f0fb2">ranges::is_heap</a> (Rng &amp;&amp;rng, C pred=C{}, P proj=P{}) -&gt; bool requires random_access_range&lt; Rng &gt; &amp;&amp;indirect_strict_weak_order&lt; C, projected&lt; iterator_t&lt; Rng &gt;, P &gt;&gt;</td></tr>
<tr class="separator:ga650418789a5ddc477e26fad6fe7f0fb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc783f9d6702126f1cfe3971cc24af52"><td class="memTemplParams" colspan="2"><a id="gafc783f9d6702126f1cfe3971cc24af52"></a>
template&lt;typename I , typename S , typename C  = less, typename P  = identity&gt; </td></tr>
<tr class="memitem:gafc783f9d6702126f1cfe3971cc24af52"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gafc783f9d6702126f1cfe3971cc24af52">ranges::is_heap_until</a> (I first, S last, C pred=C{}, P proj=P{}) -&gt; I requires random_access_iterator&lt; I &gt; &amp;&amp;sentinel_for&lt; S, I &gt; &amp;&amp;indirect_strict_weak_order&lt; C, projected&lt; I, P &gt;&gt;</td></tr>
<tr class="memdesc:gafc783f9d6702126f1cfe3971cc24af52"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>is_heap_until</code> <br /></td></tr>
<tr class="separator:gafc783f9d6702126f1cfe3971cc24af52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga79c070bf7916a0903bf1e910f4b8bf7f"><td class="memTemplParams" colspan="2">template&lt;typename Rng , typename C  = less, typename P  = identity&gt; </td></tr>
<tr class="memitem:ga79c070bf7916a0903bf1e910f4b8bf7f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga79c070bf7916a0903bf1e910f4b8bf7f">ranges::is_heap_until</a> (Rng &amp;&amp;rng, C pred=C{}, P proj=P{}) -&gt; safe_iterator_t&lt; Rng &gt; requires random_access_range&lt; Rng &gt; &amp;&amp;indirect_strict_weak_order&lt; C, projected&lt; iterator_t&lt; Rng &gt;, P &gt;&gt;</td></tr>
<tr class="separator:ga79c070bf7916a0903bf1e910f4b8bf7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga296ccfa60177c85c2d1104761178334f"><td class="memTemplParams" colspan="2"><a id="ga296ccfa60177c85c2d1104761178334f"></a>
template&lt;typename I , typename S , typename C , typename P  = identity&gt; </td></tr>
<tr class="memitem:ga296ccfa60177c85c2d1104761178334f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga296ccfa60177c85c2d1104761178334f">ranges::is_partitioned</a> (I first, S last, C pred, P proj=P{}) -&gt; bool requires input_iterator&lt; I &gt; &amp;&amp;sentinel_for&lt; S, I &gt; &amp;&amp;indirect_unary_predicate&lt; C, projected&lt; I, P &gt;&gt;</td></tr>
<tr class="memdesc:ga296ccfa60177c85c2d1104761178334f"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>is_partitioned</code> <br /></td></tr>
<tr class="separator:ga296ccfa60177c85c2d1104761178334f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada630b75096ea1e1276173e0b6464ed6"><td class="memTemplParams" colspan="2">template&lt;typename Rng , typename C , typename P  = identity&gt; </td></tr>
<tr class="memitem:gada630b75096ea1e1276173e0b6464ed6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gada630b75096ea1e1276173e0b6464ed6">ranges::is_partitioned</a> (Rng &amp;&amp;rng, C pred, P proj=P{}) -&gt; bool requires input_range&lt; Rng &gt; &amp;&amp;indirect_unary_predicate&lt; C, projected&lt; iterator_t&lt; Rng &gt;, P &gt;&gt;</td></tr>
<tr class="separator:gada630b75096ea1e1276173e0b6464ed6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53acd367f03caa54ca29bb2d70e61eba"><td class="memTemplParams" colspan="2"><a id="ga53acd367f03caa54ca29bb2d70e61eba"></a>
template&lt;typename I1 , typename S1 , typename I2 , typename C  = equal_to, typename P1  = identity, typename P2  = identity&gt; </td></tr>
<tr class="memitem:ga53acd367f03caa54ca29bb2d70e61eba"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga53acd367f03caa54ca29bb2d70e61eba">ranges::is_permutation</a> (I1 begin1, S1 end1, I2 begin2, C pred=C{}, P1 proj1=P1{}, P2 proj2=P2{}) -&gt; bool requires forward_iterator&lt; I1 &gt; &amp;&amp;sentinel_for&lt; S1, I1 &gt; &amp;&amp;forward_iterator&lt; I2 &gt; &amp;&amp;indirectly_comparable&lt; I1, I2, C, P1, P2 &gt;</td></tr>
<tr class="memdesc:ga53acd367f03caa54ca29bb2d70e61eba"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>is_permutation</code> <br /></td></tr>
<tr class="separator:ga53acd367f03caa54ca29bb2d70e61eba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa6c38c42c15abc90162194dad95b216b"><td class="memTemplParams" colspan="2">template&lt;typename I1 , typename S1 , typename I2 , typename S2 , typename C  = equal_to, typename P1  = identity, typename P2  = identity&gt; </td></tr>
<tr class="memitem:gaa6c38c42c15abc90162194dad95b216b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gaa6c38c42c15abc90162194dad95b216b">ranges::is_permutation</a> (I1 begin1, S1 end1, I2 begin2, S2 end2, C pred=C{}, P1 proj1=P1{}, P2 proj2=P2{}) -&gt; bool requires forward_iterator&lt; I1 &gt; &amp;&amp;sentinel_for&lt; S1, I1 &gt; &amp;&amp;forward_iterator&lt; I2 &gt; &amp;&amp;sentinel_for&lt; S2, I2 &gt; &amp;&amp;indirectly_comparable&lt; I1, I2, C, P1, P2 &gt;</td></tr>
<tr class="separator:gaa6c38c42c15abc90162194dad95b216b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafba37d0b7f7fc51effa32f19baa56ad8"><td class="memTemplParams" colspan="2">template&lt;typename Rng1 , typename I2Ref , typename C  = equal_to, typename P1  = identity, typename P2  = identity&gt; </td></tr>
<tr class="memitem:gafba37d0b7f7fc51effa32f19baa56ad8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gafba37d0b7f7fc51effa32f19baa56ad8">ranges::is_permutation</a> (Rng1 &amp;&amp;rng1, I2Ref &amp;&amp;begin2, C pred=C{}, P1 proj1=P1{}, P2 proj2=P2{}) -&gt; bool requires forward_range&lt; Rng1 &gt; &amp;&amp;forward_iterator&lt; uncvref_t&lt; I2Ref &gt;&gt; &amp;&amp;indirectly_comparable&lt; iterator_t&lt; Rng1 &gt;, uncvref_t&lt; I2Ref &gt;, C, P1, P2 &gt;</td></tr>
<tr class="separator:gafba37d0b7f7fc51effa32f19baa56ad8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga74f17609033a0f20f0bc6482d91a7aca"><td class="memTemplParams" colspan="2">template&lt;typename Rng1 , typename Rng2 , typename C  = equal_to, typename P1  = identity, typename P2  = identity&gt; </td></tr>
<tr class="memitem:ga74f17609033a0f20f0bc6482d91a7aca"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga74f17609033a0f20f0bc6482d91a7aca">ranges::is_permutation</a> (Rng1 &amp;&amp;rng1, Rng2 &amp;&amp;rng2, C pred=C{}, P1 proj1=P1{}, P2 proj2=P2{}) -&gt; bool requires forward_range&lt; Rng1 &gt; &amp;&amp;forward_range&lt; Rng2 &gt; &amp;&amp;indirectly_comparable&lt; iterator_t&lt; Rng1 &gt;, iterator_t&lt; Rng2 &gt;, C, P1, P2 &gt;</td></tr>
<tr class="separator:ga74f17609033a0f20f0bc6482d91a7aca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ef0c9489d476d96092f8b4c77b3ccf4"><td class="memTemplParams" colspan="2">template&lt;typename I , typename S , typename R  = less, typename P  = identity&gt; </td></tr>
<tr class="memitem:ga9ef0c9489d476d96092f8b4c77b3ccf4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga9ef0c9489d476d96092f8b4c77b3ccf4">ranges::is_sorted</a> (I first, S last, R rel=R{}, P proj=P{}) -&gt; bool requires forward_iterator&lt; I &gt; &amp;&amp;sentinel_for&lt; S, I &gt; &amp;&amp;indirect_strict_weak_order&lt; R, projected&lt; I, P &gt;&gt;</td></tr>
<tr class="memdesc:ga9ef0c9489d476d96092f8b4c77b3ccf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">template function <code>is_sorted</code>  <a href="group__group-algorithms.html#ga9ef0c9489d476d96092f8b4c77b3ccf4">More...</a><br /></td></tr>
<tr class="separator:ga9ef0c9489d476d96092f8b4c77b3ccf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49836ea88cdda883cd29bc1172b2acc6"><td class="memTemplParams" colspan="2">template&lt;typename Rng , typename R  = less, typename P  = identity&gt; </td></tr>
<tr class="memitem:ga49836ea88cdda883cd29bc1172b2acc6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga49836ea88cdda883cd29bc1172b2acc6">ranges::is_sorted</a> (Rng &amp;&amp;rng, R rel=R{}, P proj=P{}) -&gt; bool requires forward_range&lt; Rng &gt; &amp;&amp;indirect_strict_weak_order&lt; R, projected&lt; iterator_t&lt; Rng &gt;, P &gt;&gt;</td></tr>
<tr class="separator:ga49836ea88cdda883cd29bc1172b2acc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1e0c8d007fae6db8abaa2f47a7cc0d9"><td class="memTemplParams" colspan="2">template&lt;typename I , typename S , typename R  = less, typename P  = identity&gt; </td></tr>
<tr class="memitem:gae1e0c8d007fae6db8abaa2f47a7cc0d9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gae1e0c8d007fae6db8abaa2f47a7cc0d9">ranges::is_sorted_until</a> (I first, S last, R pred=R{}, P proj=P{}) -&gt; I requires forward_iterator&lt; I &gt; &amp;&amp;sentinel_for&lt; S, I &gt; &amp;&amp;indirect_strict_weak_order&lt; R, projected&lt; I, P &gt;&gt;</td></tr>
<tr class="memdesc:gae1e0c8d007fae6db8abaa2f47a7cc0d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">template function <code>is_sorted_until</code>  <a href="group__group-algorithms.html#gae1e0c8d007fae6db8abaa2f47a7cc0d9">More...</a><br /></td></tr>
<tr class="separator:gae1e0c8d007fae6db8abaa2f47a7cc0d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac588ad6fdec29edaf8695c066b5251f8"><td class="memTemplParams" colspan="2">template&lt;typename Rng , typename R  = less, typename P  = identity&gt; </td></tr>
<tr class="memitem:gac588ad6fdec29edaf8695c066b5251f8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gac588ad6fdec29edaf8695c066b5251f8">ranges::is_sorted_until</a> (Rng &amp;&amp;rng, R pred=R{}, P proj=P{}) -&gt; safe_iterator_t&lt; Rng &gt; requires forward_range&lt; Rng &gt; &amp;&amp;indirect_strict_weak_order&lt; R, projected&lt; iterator_t&lt; Rng &gt;, P &gt;&gt;</td></tr>
<tr class="separator:gac588ad6fdec29edaf8695c066b5251f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ba7d0bf32c65a4d1f5ca21579671bd5"><td class="memTemplParams" colspan="2"><a id="ga5ba7d0bf32c65a4d1f5ca21579671bd5"></a>
template&lt;typename I0 , typename S0 , typename I1 , typename S1 , typename C  = less, typename P0  = identity, typename P1  = identity&gt; </td></tr>
<tr class="memitem:ga5ba7d0bf32c65a4d1f5ca21579671bd5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga5ba7d0bf32c65a4d1f5ca21579671bd5">ranges::lexicographical_compare</a> (I0 begin0, S0 end0, I1 begin1, S1 end1, C pred=C{}, P0 proj0=P0{}, P1 proj1=P1{}) -&gt; bool requires input_iterator&lt; I0 &gt; &amp;&amp;sentinel_for&lt; S0, I0 &gt; &amp;&amp;input_iterator&lt; I1 &gt; &amp;&amp;sentinel_for&lt; S1, I1 &gt; &amp;&amp;indirect_strict_weak_order&lt; C, projected&lt; I0, P0 &gt;, projected&lt; I1, P1 &gt;&gt;</td></tr>
<tr class="memdesc:ga5ba7d0bf32c65a4d1f5ca21579671bd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>lexicographical_compare</code> <br /></td></tr>
<tr class="separator:ga5ba7d0bf32c65a4d1f5ca21579671bd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1fca7df6df82e9ff76107a5cd96a9070"><td class="memTemplParams" colspan="2">template&lt;typename Rng0 , typename Rng1 , typename C  = less, typename P0  = identity, typename P1  = identity&gt; </td></tr>
<tr class="memitem:ga1fca7df6df82e9ff76107a5cd96a9070"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga1fca7df6df82e9ff76107a5cd96a9070">ranges::lexicographical_compare</a> (Rng0 &amp;&amp;rng0, Rng1 &amp;&amp;rng1, C pred=C{}, P0 proj0=P0{}, P1 proj1=P1{}) -&gt; bool requires input_range&lt; Rng0 &gt; &amp;&amp;input_range&lt; Rng1 &gt; &amp;&amp;indirect_strict_weak_order&lt; C, projected&lt; iterator_t&lt; Rng0 &gt;, P0 &gt;, projected&lt; iterator_t&lt; Rng1 &gt;, P1 &gt;&gt;</td></tr>
<tr class="separator:ga1fca7df6df82e9ff76107a5cd96a9070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6afc87cc20e5c97a032da267c93f6e5"><td class="memTemplParams" colspan="2"><a id="gaf6afc87cc20e5c97a032da267c93f6e5"></a>
template&lt;typename I , typename S , typename V , typename C  = less, typename P  = identity&gt; </td></tr>
<tr class="memitem:gaf6afc87cc20e5c97a032da267c93f6e5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gaf6afc87cc20e5c97a032da267c93f6e5">ranges::lower_bound</a> (I first, S last, V const &amp;val, C pred=C{}, P proj=P{}) -&gt; I requires forward_iterator&lt; I &gt; &amp;&amp;sentinel_for&lt; S, I &gt; &amp;&amp;indirect_strict_weak_order&lt; C, V const *, projected&lt; I, P &gt;&gt;</td></tr>
<tr class="memdesc:gaf6afc87cc20e5c97a032da267c93f6e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>lower_bound</code> <br /></td></tr>
<tr class="separator:gaf6afc87cc20e5c97a032da267c93f6e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd90b524d80aa309189dd81df16cd3a5"><td class="memTemplParams" colspan="2">template&lt;typename Rng , typename V , typename C  = less, typename P  = identity&gt; </td></tr>
<tr class="memitem:gabd90b524d80aa309189dd81df16cd3a5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gabd90b524d80aa309189dd81df16cd3a5">ranges::lower_bound</a> (Rng &amp;&amp;rng, V const &amp;val, C pred=C{}, P proj=P{}) -&gt; safe_iterator_t&lt; Rng &gt; requires forward_range&lt; Rng &gt; &amp;&amp;indirect_strict_weak_order&lt; C, V const *, projected&lt; iterator_t&lt; Rng &gt;, P &gt;&gt;</td></tr>
<tr class="separator:gabd90b524d80aa309189dd81df16cd3a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc6ac8e09952e6e66e882168d68c163d"><td class="memTemplParams" colspan="2"><a id="gafc6ac8e09952e6e66e882168d68c163d"></a>
template&lt;typename I , typename S , typename C  = less, typename P  = identity&gt; </td></tr>
<tr class="memitem:gafc6ac8e09952e6e66e882168d68c163d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gafc6ac8e09952e6e66e882168d68c163d">ranges::make_heap</a> (I first, S last, C pred=C{}, P proj=P{}) -&gt; I requires random_access_iterator&lt; I &gt; &amp;&amp;sentinel_for&lt; S, I &gt; &amp;&amp;sortable&lt; I, C, P &gt;</td></tr>
<tr class="memdesc:gafc6ac8e09952e6e66e882168d68c163d"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>make_heap</code> <br /></td></tr>
<tr class="separator:gafc6ac8e09952e6e66e882168d68c163d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf24f51e58d9b234b4687a878d65050cd"><td class="memTemplParams" colspan="2">template&lt;typename Rng , typename C  = less, typename P  = identity&gt; </td></tr>
<tr class="memitem:gaf24f51e58d9b234b4687a878d65050cd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gaf24f51e58d9b234b4687a878d65050cd">ranges::make_heap</a> (Rng &amp;&amp;rng, C pred=C{}, P proj=P{}) -&gt; safe_iterator_t&lt; Rng &gt; requires random_access_range&lt; Rng &gt; &amp;&amp;sortable&lt; iterator_t&lt; Rng &gt;, C, P &gt;</td></tr>
<tr class="separator:gaf24f51e58d9b234b4687a878d65050cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba12eee36b9ab29ef0e9b7f59e685a71"><td class="memTemplParams" colspan="2"><a id="gaba12eee36b9ab29ef0e9b7f59e685a71"></a>
template&lt;typename T , typename C  = less, typename P  = identity&gt; </td></tr>
<tr class="memitem:gaba12eee36b9ab29ef0e9b7f59e685a71"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gaba12eee36b9ab29ef0e9b7f59e685a71">ranges::max</a> (T const &amp;a, T const &amp;b, C pred=C{}, P proj=P{}) -&gt; T const &amp;requires indirect_strict_weak_order&lt; C, projected&lt; T const *, P &gt;&gt;</td></tr>
<tr class="memdesc:gaba12eee36b9ab29ef0e9b7f59e685a71"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>max</code> <br /></td></tr>
<tr class="separator:gaba12eee36b9ab29ef0e9b7f59e685a71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d4e1bb60d9bfb5e5437974eed0b03c4"><td class="memTemplParams" colspan="2">template&lt;typename Rng , typename C  = less, typename P  = identity&gt; </td></tr>
<tr class="memitem:ga1d4e1bb60d9bfb5e5437974eed0b03c4"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga1d4e1bb60d9bfb5e5437974eed0b03c4">ranges::max</a> (Rng &amp;&amp;rng, C pred=C{}, P proj=P{}) -&gt; range_value_t&lt; Rng &gt; requires input_range&lt; Rng &gt; &amp;&amp;indirect_strict_weak_order&lt; C, projected&lt; iterator_t&lt; Rng &gt;, P &gt;&gt; &amp;&amp;indirectly_copyable_storable&lt; iterator_t&lt; Rng &gt;, range_value_t&lt; Rng &gt; * &gt;</td></tr>
<tr class="separator:ga1d4e1bb60d9bfb5e5437974eed0b03c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaedb6df45bc43e4cee4be367f76786b99"><td class="memTemplParams" colspan="2">template&lt;typename T , typename C  = less, typename P  = identity&gt; </td></tr>
<tr class="memitem:gaedb6df45bc43e4cee4be367f76786b99"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gaedb6df45bc43e4cee4be367f76786b99">ranges::max</a> (std::initializer_list&lt; T &gt; const &amp;&amp;rng, C pred=C{}, P proj=P{}) -&gt; T requires copyable&lt; T &gt; &amp;&amp;indirect_strict_weak_order&lt; C, projected&lt; T const *, P &gt;&gt;</td></tr>
<tr class="separator:gaedb6df45bc43e4cee4be367f76786b99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9289134adb9df908a681c75fb60b0d7"><td class="memTemplParams" colspan="2"><a id="gab9289134adb9df908a681c75fb60b0d7"></a>
template&lt;typename I , typename S , typename C  = less, typename P  = identity&gt; </td></tr>
<tr class="memitem:gab9289134adb9df908a681c75fb60b0d7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gab9289134adb9df908a681c75fb60b0d7">ranges::max_element</a> (I first, S last, C pred=C{}, P proj=P{}) -&gt; I requires forward_iterator&lt; I &gt; &amp;&amp;sentinel_for&lt; S, I &gt; &amp;&amp;indirect_strict_weak_order&lt; C, projected&lt; I, P &gt;&gt;</td></tr>
<tr class="memdesc:gab9289134adb9df908a681c75fb60b0d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>max_element</code> <br /></td></tr>
<tr class="separator:gab9289134adb9df908a681c75fb60b0d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e5950e393a0aee33b00b34c2f8e97c9"><td class="memTemplParams" colspan="2">template&lt;typename Rng , typename C  = less, typename P  = identity&gt; </td></tr>
<tr class="memitem:ga4e5950e393a0aee33b00b34c2f8e97c9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga4e5950e393a0aee33b00b34c2f8e97c9">ranges::max_element</a> (Rng &amp;&amp;rng, C pred=C{}, P proj=P{}) -&gt; safe_iterator_t&lt; Rng &gt; requires forward_range&lt; Rng &gt; &amp;&amp;indirect_strict_weak_order&lt; C, projected&lt; iterator_t&lt; Rng &gt;, P &gt;&gt;</td></tr>
<tr class="separator:ga4e5950e393a0aee33b00b34c2f8e97c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0b29c934e59116aa62f08d48836b48d"><td class="memTemplParams" colspan="2"><a id="gab0b29c934e59116aa62f08d48836b48d"></a>
template&lt;typename I0 , typename S0 , typename I1 , typename S1 , typename O , typename C  = less, typename P0  = identity, typename P1  = identity&gt; </td></tr>
<tr class="memitem:gab0b29c934e59116aa62f08d48836b48d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gab0b29c934e59116aa62f08d48836b48d">ranges::merge</a> (I0 begin0, S0 end0, I1 begin1, S1 end1, O out, C pred=C{}, P0 proj0=P0{}, P1 proj1=P1{}) -&gt; merge_result&lt; I0, I1, O &gt; requires sentinel_for&lt; S0, I0 &gt; &amp;&amp;sentinel_for&lt; S1, I1 &gt; &amp;&amp;mergeable&lt; I0, I1, O, C, P0, P1 &gt;</td></tr>
<tr class="memdesc:gab0b29c934e59116aa62f08d48836b48d"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>merge</code> <br /></td></tr>
<tr class="separator:gab0b29c934e59116aa62f08d48836b48d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9dc32f54d90650bb5e2604f37374bea2"><td class="memTemplParams" colspan="2">template&lt;typename Rng0 , typename Rng1 , typename O , typename C  = less, typename P0  = identity, typename P1  = identity&gt; </td></tr>
<tr class="memitem:ga9dc32f54d90650bb5e2604f37374bea2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga9dc32f54d90650bb5e2604f37374bea2">ranges::merge</a> (Rng0 &amp;&amp;rng0, Rng1 &amp;&amp;rng1, O out, C pred=C{}, P0 proj0=P0{}, P1 proj1=P1{}) -&gt; merge_result&lt; safe_iterator_t&lt; Rng0 &gt;, safe_iterator_t&lt; Rng1 &gt;, O &gt; requires range&lt; Rng0 &gt; &amp;&amp;range&lt; Rng1 &gt; &amp;&amp;mergeable&lt; iterator_t&lt; Rng0 &gt;, iterator_t&lt; Rng1 &gt;, O, C, P0, P1 &gt;</td></tr>
<tr class="separator:ga9dc32f54d90650bb5e2604f37374bea2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafab64593526f59bad0f2bf5a95f96bf9"><td class="memTemplParams" colspan="2"><a id="gafab64593526f59bad0f2bf5a95f96bf9"></a>
template&lt;typename T , typename C  = less, typename P  = identity&gt; </td></tr>
<tr class="memitem:gafab64593526f59bad0f2bf5a95f96bf9"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gafab64593526f59bad0f2bf5a95f96bf9">ranges::min</a> (T const &amp;a, T const &amp;b, C pred=C{}, P proj=P{}) -&gt; T const &amp;requires indirect_strict_weak_order&lt; C, projected&lt; T const *, P &gt;&gt;</td></tr>
<tr class="memdesc:gafab64593526f59bad0f2bf5a95f96bf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>min</code> <br /></td></tr>
<tr class="separator:gafab64593526f59bad0f2bf5a95f96bf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee8206c71bf8a3141ffd74d2fa86b9ee"><td class="memTemplParams" colspan="2">template&lt;typename Rng , typename C  = less, typename P  = identity&gt; </td></tr>
<tr class="memitem:gaee8206c71bf8a3141ffd74d2fa86b9ee"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gaee8206c71bf8a3141ffd74d2fa86b9ee">ranges::min</a> (Rng &amp;&amp;rng, C pred=C{}, P proj=P{}) -&gt; range_value_t&lt; Rng &gt; requires input_range&lt; Rng &gt; &amp;&amp;indirect_strict_weak_order&lt; C, projected&lt; iterator_t&lt; Rng &gt;, P &gt;&gt; &amp;&amp;indirectly_copyable_storable&lt; iterator_t&lt; Rng &gt;, range_value_t&lt; Rng &gt; * &gt;</td></tr>
<tr class="separator:gaee8206c71bf8a3141ffd74d2fa86b9ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga483adbc4117b6a40342fffe1d0472c1a"><td class="memTemplParams" colspan="2">template&lt;typename T , typename C  = less, typename P  = identity&gt; </td></tr>
<tr class="memitem:ga483adbc4117b6a40342fffe1d0472c1a"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga483adbc4117b6a40342fffe1d0472c1a">ranges::min</a> (std::initializer_list&lt; T &gt; const &amp;&amp;rng, C pred=C{}, P proj=P{}) -&gt; T requires copyable&lt; T &gt; &amp;&amp;indirect_strict_weak_order&lt; C, projected&lt; T const *, P &gt;&gt;</td></tr>
<tr class="separator:ga483adbc4117b6a40342fffe1d0472c1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5889278c5c0850d6ce8a2579991109c3"><td class="memTemplParams" colspan="2"><a id="ga5889278c5c0850d6ce8a2579991109c3"></a>
template&lt;typename I , typename S , typename C  = less, typename P  = identity&gt; </td></tr>
<tr class="memitem:ga5889278c5c0850d6ce8a2579991109c3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga5889278c5c0850d6ce8a2579991109c3">ranges::min_element</a> (I first, S last, C pred=C{}, P proj=P{}) -&gt; I requires forward_iterator&lt; I &gt; &amp;&amp;sentinel_for&lt; S, I &gt; &amp;&amp;indirect_strict_weak_order&lt; C, projected&lt; I, P &gt;&gt;</td></tr>
<tr class="memdesc:ga5889278c5c0850d6ce8a2579991109c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>min_element</code> <br /></td></tr>
<tr class="separator:ga5889278c5c0850d6ce8a2579991109c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa486ad46a5307c11a3d1be2f6683cf1c"><td class="memTemplParams" colspan="2">template&lt;typename Rng , typename C  = less, typename P  = identity&gt; </td></tr>
<tr class="memitem:gaa486ad46a5307c11a3d1be2f6683cf1c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gaa486ad46a5307c11a3d1be2f6683cf1c">ranges::min_element</a> (Rng &amp;&amp;rng, C pred=C{}, P proj=P{}) -&gt; safe_iterator_t&lt; Rng &gt; requires forward_range&lt; Rng &gt; &amp;&amp;indirect_strict_weak_order&lt; C, projected&lt; iterator_t&lt; Rng &gt;, P &gt;&gt;</td></tr>
<tr class="separator:gaa486ad46a5307c11a3d1be2f6683cf1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7746e5071777bfa8943211520a5e7ed"><td class="memTemplParams" colspan="2"><a id="gab7746e5071777bfa8943211520a5e7ed"></a>
template&lt;typename T , typename C  = less, typename P  = identity&gt; </td></tr>
<tr class="memitem:gab7746e5071777bfa8943211520a5e7ed"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gab7746e5071777bfa8943211520a5e7ed">ranges::minmax</a> (T const &amp;a, T const &amp;b, C pred=C{}, P proj=P{}) -&gt; minmax_result&lt; T const &amp; &gt; requires indirect_strict_weak_order&lt; C, projected&lt; T const *, P &gt;&gt;</td></tr>
<tr class="memdesc:gab7746e5071777bfa8943211520a5e7ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>minmax</code> <br /></td></tr>
<tr class="separator:gab7746e5071777bfa8943211520a5e7ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93f42f45f3ba905e1eb1cd573f172a4b"><td class="memTemplParams" colspan="2">template&lt;typename Rng , typename C  = less, typename P  = identity&gt; </td></tr>
<tr class="memitem:ga93f42f45f3ba905e1eb1cd573f172a4b"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga93f42f45f3ba905e1eb1cd573f172a4b">ranges::minmax</a> (Rng &amp;&amp;rng, C pred=C{}, P proj=P{}) -&gt; minmax_result&lt; range_value_t&lt; Rng &gt;&gt; requires input_range&lt; Rng &gt; &amp;&amp;indirect_strict_weak_order&lt; C, projected&lt; iterator_t&lt; Rng &gt;, P &gt;&gt; &amp;&amp;indirectly_copyable_storable&lt; iterator_t&lt; Rng &gt;, range_value_t&lt; Rng &gt; * &gt;</td></tr>
<tr class="separator:ga93f42f45f3ba905e1eb1cd573f172a4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f84b92881ac8d36ec500601758b489e"><td class="memTemplParams" colspan="2">template&lt;typename T , typename C  = less, typename P  = identity&gt; </td></tr>
<tr class="memitem:ga7f84b92881ac8d36ec500601758b489e"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga7f84b92881ac8d36ec500601758b489e">ranges::minmax</a> (std::initializer_list&lt; T &gt; const &amp;&amp;rng, C pred=C{}, P proj=P{}) -&gt; minmax_result&lt; T &gt; requires copyable&lt; T &gt; &amp;&amp;indirect_strict_weak_order&lt; C, projected&lt; T const *, P &gt;&gt;</td></tr>
<tr class="separator:ga7f84b92881ac8d36ec500601758b489e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga941f844d9a850179cb16a4ccc5b9b071"><td class="memTemplParams" colspan="2"><a id="ga941f844d9a850179cb16a4ccc5b9b071"></a>
template&lt;typename I , typename S , typename C  = less, typename P  = identity&gt; </td></tr>
<tr class="memitem:ga941f844d9a850179cb16a4ccc5b9b071"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga941f844d9a850179cb16a4ccc5b9b071">ranges::minmax_element</a> (I first, S last, C pred=C{}, P proj=P{}) -&gt; minmax_element_result&lt; I &gt; requires forward_iterator&lt; I &gt; &amp;&amp;sentinel_for&lt; S, I &gt; &amp;&amp;indirect_strict_weak_order&lt; C, projected&lt; I, P &gt;&gt;</td></tr>
<tr class="memdesc:ga941f844d9a850179cb16a4ccc5b9b071"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>minmax_element</code> <br /></td></tr>
<tr class="separator:ga941f844d9a850179cb16a4ccc5b9b071"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae13f61b4b199b34e72551c035de4a491"><td class="memTemplParams" colspan="2">template&lt;typename Rng , typename C  = less, typename P  = identity&gt; </td></tr>
<tr class="memitem:gae13f61b4b199b34e72551c035de4a491"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gae13f61b4b199b34e72551c035de4a491">ranges::minmax_element</a> (Rng &amp;&amp;rng, C pred=C{}, P proj=P{}) -&gt; minmax_element_result&lt; safe_iterator_t&lt; Rng &gt;&gt; requires forward_range&lt; Rng &gt; &amp;&amp;indirect_strict_weak_order&lt; C, projected&lt; iterator_t&lt; Rng &gt;, P &gt;&gt;</td></tr>
<tr class="separator:gae13f61b4b199b34e72551c035de4a491"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0dbe34565e3046d0f7fd3c8fadaa5ccd"><td class="memTemplParams" colspan="2"><a id="ga0dbe34565e3046d0f7fd3c8fadaa5ccd"></a>
template&lt;typename I1 , typename S1 , typename I2 , typename C  = equal_to, typename P1  = identity, typename P2  = identity&gt; </td></tr>
<tr class="memitem:ga0dbe34565e3046d0f7fd3c8fadaa5ccd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga0dbe34565e3046d0f7fd3c8fadaa5ccd">ranges::mismatch</a> (I1 begin1, S1 end1, I2 begin2, C pred=C{}, P1 proj1=P1{}, P2 proj2=P2{}) -&gt; mismatch_result&lt; I1, I2 &gt; requires input_iterator&lt; I1 &gt; &amp;&amp;sentinel_for&lt; S1, I1 &gt; &amp;&amp;input_iterator&lt; I2 &gt; &amp;&amp;indirect_relation&lt; C, projected&lt; I1, P1 &gt;, projected&lt; I2, P2 &gt;&gt;</td></tr>
<tr class="memdesc:ga0dbe34565e3046d0f7fd3c8fadaa5ccd"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>mismatch</code> <br /></td></tr>
<tr class="separator:ga0dbe34565e3046d0f7fd3c8fadaa5ccd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4da42176e10f531b5b742c55dd5647d0"><td class="memTemplParams" colspan="2">template&lt;typename I1 , typename S1 , typename I2 , typename S2 , typename C  = equal_to, typename P1  = identity, typename P2  = identity&gt; </td></tr>
<tr class="memitem:ga4da42176e10f531b5b742c55dd5647d0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga4da42176e10f531b5b742c55dd5647d0">ranges::mismatch</a> (I1 begin1, S1 end1, I2 begin2, S2 end2, C pred=C{}, P1 proj1=P1{}, P2 proj2=P2{}) -&gt; mismatch_result&lt; I1, I2 &gt; requires input_iterator&lt; I1 &gt; &amp;&amp;sentinel_for&lt; S1, I1 &gt; &amp;&amp;input_iterator&lt; I2 &gt; &amp;&amp;sentinel_for&lt; S2, I2 &gt; &amp;&amp;indirect_relation&lt; C, projected&lt; I1, P1 &gt;, projected&lt; I2, P2 &gt;&gt;</td></tr>
<tr class="separator:ga4da42176e10f531b5b742c55dd5647d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafdbcd0a2e221a907444f025e93bac41f"><td class="memTemplParams" colspan="2">template&lt;typename Rng1 , typename I2Ref , typename C  = equal_to, typename P1  = identity, typename P2  = identity&gt; </td></tr>
<tr class="memitem:gafdbcd0a2e221a907444f025e93bac41f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gafdbcd0a2e221a907444f025e93bac41f">ranges::mismatch</a> (Rng1 &amp;&amp;rng1, I2Ref &amp;&amp;begin2, C pred=C{}, P1 proj1=P1{}, P2 proj2=P2{}) -&gt; mismatch_result&lt; safe_iterator_t&lt; Rng1 &gt;, uncvref_t&lt; I2Ref &gt;&gt; requires input_range&lt; Rng1 &gt; &amp;&amp;input_iterator&lt; uncvref_t&lt; I2Ref &gt;&gt; &amp;&amp;indirect_relation&lt; C, projected&lt; iterator_t&lt; Rng1 &gt;, P1 &gt;, projected&lt; uncvref_t&lt; I2Ref &gt;, P2 &gt;&gt;</td></tr>
<tr class="separator:gafdbcd0a2e221a907444f025e93bac41f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9b4343602798cdf8687652d39af9486"><td class="memTemplParams" colspan="2">template&lt;typename Rng1 , typename Rng2 , typename C  = equal_to, typename P1  = identity, typename P2  = identity&gt; </td></tr>
<tr class="memitem:gae9b4343602798cdf8687652d39af9486"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gae9b4343602798cdf8687652d39af9486">ranges::mismatch</a> (Rng1 &amp;&amp;rng1, Rng2 &amp;&amp;rng2, C pred=C{}, P1 proj1=P1{}, P2 proj2=P2{}) -&gt; mismatch_result&lt; safe_iterator_t&lt; Rng1 &gt;, safe_iterator_t&lt; Rng2 &gt;&gt; requires input_range&lt; Rng1 &gt; &amp;&amp;input_range&lt; Rng2 &gt; &amp;&amp;indirect_relation&lt; C, projected&lt; iterator_t&lt; Rng1 &gt;, P1 &gt;, projected&lt; iterator_t&lt; Rng2 &gt;, P2 &gt;&gt;</td></tr>
<tr class="separator:gae9b4343602798cdf8687652d39af9486"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51a5571f63c297cfd285f4a3873737dc"><td class="memTemplParams" colspan="2"><a id="ga51a5571f63c297cfd285f4a3873737dc"></a>
template&lt;typename I , typename S , typename O &gt; </td></tr>
<tr class="memitem:ga51a5571f63c297cfd285f4a3873737dc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga51a5571f63c297cfd285f4a3873737dc">ranges::move</a> (I first, S last, O out) -&gt; move_result&lt; I, O &gt; requires input_iterator&lt; I &gt; &amp;&amp;sentinel_for&lt; S, I &gt; &amp;&amp;weakly_incrementable&lt; O &gt; &amp;&amp;indirectly_movable&lt; I, O &gt;</td></tr>
<tr class="memdesc:ga51a5571f63c297cfd285f4a3873737dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>move</code> <br /></td></tr>
<tr class="separator:ga51a5571f63c297cfd285f4a3873737dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa55485146994b298d1392f1aa421fdfe"><td class="memTemplParams" colspan="2">template&lt;typename Rng , typename O &gt; </td></tr>
<tr class="memitem:gaa55485146994b298d1392f1aa421fdfe"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gaa55485146994b298d1392f1aa421fdfe">ranges::move</a> (Rng &amp;&amp;rng, O out) -&gt; move_result&lt; safe_iterator_t&lt; Rng &gt;, O &gt; requires input_range&lt; Rng &gt; &amp;&amp;weakly_incrementable&lt; O &gt; &amp;&amp;indirectly_movable&lt; iterator_t&lt; Rng &gt;, O &gt;</td></tr>
<tr class="separator:gaa55485146994b298d1392f1aa421fdfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86b73aec0c528d6500d8df10b46eb4b3"><td class="memTemplParams" colspan="2"><a id="ga86b73aec0c528d6500d8df10b46eb4b3"></a>
template&lt;typename I , typename S , typename O &gt; </td></tr>
<tr class="memitem:ga86b73aec0c528d6500d8df10b46eb4b3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga86b73aec0c528d6500d8df10b46eb4b3">ranges::move_backward</a> (I first, S end_, O out) -&gt; move_backward_result&lt; I, O &gt; requires bidirectional_iterator&lt; I &gt; &amp;&amp;sentinel_for&lt; S, I &gt; &amp;&amp;bidirectional_iterator&lt; O &gt; &amp;&amp;indirectly_movable&lt; I, O &gt;</td></tr>
<tr class="memdesc:ga86b73aec0c528d6500d8df10b46eb4b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>move_backward</code> <br /></td></tr>
<tr class="separator:ga86b73aec0c528d6500d8df10b46eb4b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1bcb9fe56632812478c526a887f97e95"><td class="memTemplParams" colspan="2">template&lt;typename Rng , typename O &gt; </td></tr>
<tr class="memitem:ga1bcb9fe56632812478c526a887f97e95"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga1bcb9fe56632812478c526a887f97e95">ranges::move_backward</a> (Rng &amp;&amp;rng, O out) -&gt; move_backward_result&lt; safe_iterator_t&lt; Rng &gt;, O &gt; requires bidirectional_range&lt; Rng &gt; &amp;&amp;bidirectional_iterator&lt; O &gt; &amp;&amp;indirectly_movable&lt; iterator_t&lt; Rng &gt;, O &gt;</td></tr>
<tr class="separator:ga1bcb9fe56632812478c526a887f97e95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0cb1e10c1bb0af166f8fcbe632b6970"><td class="memTemplParams" colspan="2"><a id="gab0cb1e10c1bb0af166f8fcbe632b6970"></a>
template&lt;typename I , typename S , typename C  = less, typename P  = identity&gt; </td></tr>
<tr class="memitem:gab0cb1e10c1bb0af166f8fcbe632b6970"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gab0cb1e10c1bb0af166f8fcbe632b6970">ranges::next_permutation</a> (I first, S end_, C pred=C{}, P proj=P{}) -&gt; bool requires bidirectional_iterator&lt; I &gt; &amp;&amp;sentinel_for&lt; S, I &gt; &amp;&amp;sortable&lt; I, C, P &gt;</td></tr>
<tr class="memdesc:gab0cb1e10c1bb0af166f8fcbe632b6970"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>next_permutation</code> <br /></td></tr>
<tr class="separator:gab0cb1e10c1bb0af166f8fcbe632b6970"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac1d3b1235061a7fe7e207b40ed5cfe6a"><td class="memTemplParams" colspan="2">template&lt;typename Rng , typename C  = less, typename P  = identity&gt; </td></tr>
<tr class="memitem:gac1d3b1235061a7fe7e207b40ed5cfe6a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gac1d3b1235061a7fe7e207b40ed5cfe6a">ranges::next_permutation</a> (Rng &amp;&amp;rng, C pred=C{}, P proj=P{}) -&gt; bool requires bidirectional_range&lt; Rng &gt; &amp;&amp;sortable&lt; iterator_t&lt; Rng &gt;, C, P &gt;</td></tr>
<tr class="separator:gac1d3b1235061a7fe7e207b40ed5cfe6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e56facc7f6003fa507c604409f24a13"><td class="memTemplParams" colspan="2"><a id="ga9e56facc7f6003fa507c604409f24a13"></a>
template&lt;typename I , typename S , typename F , typename P  = identity&gt; </td></tr>
<tr class="memitem:ga9e56facc7f6003fa507c604409f24a13"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga9e56facc7f6003fa507c604409f24a13">ranges::none_of</a> (I first, S last, F pred, P proj=P{}) -&gt; bool requires input_iterator&lt; I &gt; &amp;&amp;sentinel_for&lt; S, I &gt; &amp;&amp;indirect_unary_predicate&lt; F, projected&lt; I, P &gt;&gt;</td></tr>
<tr class="memdesc:ga9e56facc7f6003fa507c604409f24a13"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>none_of</code> <br /></td></tr>
<tr class="separator:ga9e56facc7f6003fa507c604409f24a13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d61f3bfd6407213b28b03fba22596bc"><td class="memTemplParams" colspan="2">template&lt;typename Rng , typename F , typename P  = identity&gt; </td></tr>
<tr class="memitem:ga7d61f3bfd6407213b28b03fba22596bc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga7d61f3bfd6407213b28b03fba22596bc">ranges::none_of</a> (Rng &amp;&amp;rng, F pred, P proj=P{}) -&gt; bool requires input_range&lt; Rng &gt; &amp;&amp;indirect_unary_predicate&lt; F, projected&lt; iterator_t&lt; Rng &gt;, P &gt;&gt;</td></tr>
<tr class="separator:ga7d61f3bfd6407213b28b03fba22596bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8cd400e789d344237d1a14b669390ac1"><td class="memTemplParams" colspan="2"><a id="ga8cd400e789d344237d1a14b669390ac1"></a>
template&lt;typename I , typename S , typename C  = less, typename P  = identity&gt; </td></tr>
<tr class="memitem:ga8cd400e789d344237d1a14b669390ac1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga8cd400e789d344237d1a14b669390ac1">ranges::nth_element</a> (I first, I nth, S end_, C pred=C{}, P proj=P{}) -&gt; I requires random_access_iterator&lt; I &gt; &amp;&amp;sortable&lt; I, C, P &gt;</td></tr>
<tr class="memdesc:ga8cd400e789d344237d1a14b669390ac1"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>nth_element</code> <br /></td></tr>
<tr class="separator:ga8cd400e789d344237d1a14b669390ac1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5b147dfccbce1396a9b0442b20fd066"><td class="memTemplParams" colspan="2">template&lt;typename Rng , typename C  = less, typename P  = identity&gt; </td></tr>
<tr class="memitem:gaa5b147dfccbce1396a9b0442b20fd066"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gaa5b147dfccbce1396a9b0442b20fd066">ranges::nth_element</a> (Rng &amp;&amp;rng, iterator_t&lt; Rng &gt; nth, C pred=C{}, P proj=P{}) -&gt; safe_iterator_t&lt; Rng &gt; requires random_access_range&lt; Rng &gt; &amp;&amp;sortable&lt; iterator_t&lt; Rng &gt;, C, P &gt;</td></tr>
<tr class="separator:gaa5b147dfccbce1396a9b0442b20fd066"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b19bd2083263f920d49d2e44e3d9643"><td class="memTemplParams" colspan="2"><a id="ga8b19bd2083263f920d49d2e44e3d9643"></a>
template&lt;typename I , typename S , typename C  = less, typename P  = identity&gt; </td></tr>
<tr class="memitem:ga8b19bd2083263f920d49d2e44e3d9643"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga8b19bd2083263f920d49d2e44e3d9643">ranges::partial_sort</a> (I first, I middle, S last, C pred=C{}, P proj=P{}) -&gt; I requires sortable&lt; I, C, P &gt; &amp;&amp;random_access_iterator&lt; I &gt; &amp;&amp;sentinel_for&lt; S, I &gt;</td></tr>
<tr class="memdesc:ga8b19bd2083263f920d49d2e44e3d9643"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>partial_sort</code> <br /></td></tr>
<tr class="separator:ga8b19bd2083263f920d49d2e44e3d9643"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafbd4c9c1cbca2961915d60ab126c5599"><td class="memTemplParams" colspan="2">template&lt;typename Rng , typename C  = less, typename P  = identity&gt; </td></tr>
<tr class="memitem:gafbd4c9c1cbca2961915d60ab126c5599"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gafbd4c9c1cbca2961915d60ab126c5599">ranges::partial_sort</a> (Rng &amp;&amp;rng, iterator_t&lt; Rng &gt; middle, C pred=C{}, P proj=P{}) -&gt; safe_iterator_t&lt; Rng &gt; requires sortable&lt; iterator_t&lt; Rng &gt;, C, P &gt; &amp;&amp;random_access_range&lt; Rng &gt;</td></tr>
<tr class="separator:gafbd4c9c1cbca2961915d60ab126c5599"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38b870ec5158113f9b7afb74e7e95057"><td class="memTemplParams" colspan="2"><a id="ga38b870ec5158113f9b7afb74e7e95057"></a>
template&lt;typename I , typename SI , typename O , typename SO , typename C  = less, typename PI  = identity, typename PO  = identity&gt; </td></tr>
<tr class="memitem:ga38b870ec5158113f9b7afb74e7e95057"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga38b870ec5158113f9b7afb74e7e95057">ranges::partial_sort_copy</a> (I first, SI last, O out_begin, SO out_end, C pred=C{}, PI in_proj=PI{}, PO out_proj=PO{}) -&gt; O requires input_iterator&lt; I &gt; &amp;&amp;sentinel_for&lt; SI, I &gt; &amp;&amp;random_access_iterator&lt; O &gt; &amp;&amp;sentinel_for&lt; SO, O &gt; &amp;&amp;indirectly_copyable&lt; I, O &gt; &amp;&amp;sortable&lt; O, C, PO &gt; &amp;&amp;indirect_strict_weak_order&lt; C, projected&lt; I, PI &gt;, projected&lt; O, PO &gt;&gt;</td></tr>
<tr class="memdesc:ga38b870ec5158113f9b7afb74e7e95057"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>partial_sort_copy</code> <br /></td></tr>
<tr class="separator:ga38b870ec5158113f9b7afb74e7e95057"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85ad09432b8357decede032bc1132cc4"><td class="memTemplParams" colspan="2">template&lt;typename InRng , typename OutRng , typename C  = less, typename PI  = identity, typename PO  = identity&gt; </td></tr>
<tr class="memitem:ga85ad09432b8357decede032bc1132cc4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga85ad09432b8357decede032bc1132cc4">ranges::partial_sort_copy</a> (InRng &amp;&amp;in_rng, OutRng &amp;&amp;out_rng, C pred=C{}, PI in_proj=PI{}, PO out_proj=PO{}) -&gt; safe_iterator_t&lt; OutRng &gt; requires input_range&lt; InRng &gt; &amp;&amp;random_access_range&lt; OutRng &gt; &amp;&amp;indirectly_copyable&lt; iterator_t&lt; InRng &gt;, iterator_t&lt; OutRng &gt;&gt; &amp;&amp;sortable&lt; iterator_t&lt; OutRng &gt;, C, PO &gt; &amp;&amp;indirect_strict_weak_order&lt; C, projected&lt; iterator_t&lt; InRng &gt;, PI &gt;, projected&lt; iterator_t&lt; OutRng &gt;, PO &gt;&gt;</td></tr>
<tr class="separator:ga85ad09432b8357decede032bc1132cc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44ec603253c1d8b7db74726ff72fcab7"><td class="memTemplParams" colspan="2"><a id="ga44ec603253c1d8b7db74726ff72fcab7"></a>
template&lt;typename I , typename S , typename C , typename P  = identity&gt; </td></tr>
<tr class="memitem:ga44ec603253c1d8b7db74726ff72fcab7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga44ec603253c1d8b7db74726ff72fcab7">ranges::partition</a> (I first, S last, C pred, P proj=P{}) -&gt; I requires permutable&lt; I &gt; &amp;&amp;sentinel_for&lt; S, I &gt; &amp;&amp;indirect_unary_predicate&lt; C, projected&lt; I, P &gt;&gt;</td></tr>
<tr class="memdesc:ga44ec603253c1d8b7db74726ff72fcab7"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>partition</code> <br /></td></tr>
<tr class="separator:ga44ec603253c1d8b7db74726ff72fcab7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe6a0c55a56570b91f62b59f9dc906c7"><td class="memTemplParams" colspan="2">template&lt;typename Rng , typename C , typename P  = identity&gt; </td></tr>
<tr class="memitem:gabe6a0c55a56570b91f62b59f9dc906c7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gabe6a0c55a56570b91f62b59f9dc906c7">ranges::partition</a> (Rng &amp;&amp;rng, C pred, P proj=P{}) -&gt; safe_iterator_t&lt; Rng &gt; requires forward_range&lt; Rng &gt; &amp;&amp;permutable&lt; iterator_t&lt; Rng &gt;&gt; &amp;&amp;indirect_unary_predicate&lt; C, projected&lt; iterator_t&lt; Rng &gt;, P &gt;&gt;</td></tr>
<tr class="separator:gabe6a0c55a56570b91f62b59f9dc906c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga185594ec5d6552ed26713d8080b5f453"><td class="memTemplParams" colspan="2"><a id="ga185594ec5d6552ed26713d8080b5f453"></a>
template&lt;typename I , typename S , typename O0 , typename O1 , typename C , typename P  = identity&gt; </td></tr>
<tr class="memitem:ga185594ec5d6552ed26713d8080b5f453"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga185594ec5d6552ed26713d8080b5f453">ranges::partition_copy</a> (I first, S last, O0 o0, O1 o1, C pred, P proj=P{}) -&gt; partition_copy_result&lt; I, O0, O1 &gt; requires input_iterator&lt; I &gt; &amp;&amp;sentinel_for&lt; S, I &gt; &amp;&amp;weakly_incrementable&lt; O0 &gt; &amp;&amp;weakly_incrementable&lt; O1 &gt; &amp;&amp;indirectly_copyable&lt; I, O0 &gt; &amp;&amp;indirectly_copyable&lt; I, O1 &gt; &amp;&amp;indirect_unary_predicate&lt; C, projected&lt; I, P &gt;&gt;</td></tr>
<tr class="memdesc:ga185594ec5d6552ed26713d8080b5f453"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>partition_copy</code> <br /></td></tr>
<tr class="separator:ga185594ec5d6552ed26713d8080b5f453"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ab1056bfb465fe2475dee970b81c9b5"><td class="memTemplParams" colspan="2">template&lt;typename Rng , typename O0 , typename O1 , typename C , typename P  = identity&gt; </td></tr>
<tr class="memitem:ga4ab1056bfb465fe2475dee970b81c9b5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga4ab1056bfb465fe2475dee970b81c9b5">ranges::partition_copy</a> (Rng &amp;&amp;rng, O0 o0, O1 o1, C pred, P proj=P{}) -&gt; partition_copy_result&lt; safe_iterator_t&lt; Rng &gt;, O0, O1 &gt; requires input_range&lt; Rng &gt; &amp;&amp;weakly_incrementable&lt; O0 &gt; &amp;&amp;weakly_incrementable&lt; O1 &gt; &amp;&amp;indirectly_copyable&lt; iterator_t&lt; Rng &gt;, O0 &gt; &amp;&amp;indirectly_copyable&lt; iterator_t&lt; Rng &gt;, O1 &gt; &amp;&amp;indirect_unary_predicate&lt; C, projected&lt; iterator_t&lt; Rng &gt;, P &gt;&gt;</td></tr>
<tr class="separator:ga4ab1056bfb465fe2475dee970b81c9b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe997b7753be04c30cdf8dc4e0db5053"><td class="memTemplParams" colspan="2"><a id="gafe997b7753be04c30cdf8dc4e0db5053"></a>
template&lt;typename I , typename S , typename C , typename P  = identity&gt; </td></tr>
<tr class="memitem:gafe997b7753be04c30cdf8dc4e0db5053"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gafe997b7753be04c30cdf8dc4e0db5053">ranges::partition_point</a> (I first, S last, C pred, P proj=P{}) -&gt; I requires forward_iterator&lt; I &gt; &amp;&amp;sentinel_for&lt; S, I &gt; &amp;&amp;indirect_unary_predicate&lt; C, projected&lt; I, P &gt;&gt;</td></tr>
<tr class="memdesc:gafe997b7753be04c30cdf8dc4e0db5053"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>partition_point</code> <br /></td></tr>
<tr class="separator:gafe997b7753be04c30cdf8dc4e0db5053"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee84a023a3794c8c42b117029542489e"><td class="memTemplParams" colspan="2">template&lt;typename Rng , typename C , typename P  = identity&gt; </td></tr>
<tr class="memitem:gaee84a023a3794c8c42b117029542489e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gaee84a023a3794c8c42b117029542489e">ranges::partition_point</a> (Rng &amp;&amp;rng, C pred, P proj=P{}) -&gt; safe_iterator_t&lt; Rng &gt; requires forward_range&lt; Rng &gt; &amp;&amp;indirect_unary_predicate&lt; C, projected&lt; iterator_t&lt; Rng &gt;, P &gt;&gt;</td></tr>
<tr class="separator:gaee84a023a3794c8c42b117029542489e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac0fcca088187d1445ffb9d8546d15476"><td class="memTemplParams" colspan="2"><a id="gac0fcca088187d1445ffb9d8546d15476"></a>
template&lt;typename I , typename S , typename C  = less, typename P  = identity&gt; </td></tr>
<tr class="memitem:gac0fcca088187d1445ffb9d8546d15476"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gac0fcca088187d1445ffb9d8546d15476">ranges::pop_heap</a> (I first, S last, C pred=C{}, P proj=P{}) -&gt; I requires random_access_iterator&lt; I &gt; &amp;&amp;sentinel_for&lt; S, I &gt; &amp;&amp;sortable&lt; I, C, P &gt;</td></tr>
<tr class="memdesc:gac0fcca088187d1445ffb9d8546d15476"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>pop_heap</code> <br /></td></tr>
<tr class="separator:gac0fcca088187d1445ffb9d8546d15476"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ca283ec71107d67f4f0785ca8e51bb6"><td class="memTemplParams" colspan="2">template&lt;typename Rng , typename C  = less, typename P  = identity&gt; </td></tr>
<tr class="memitem:ga9ca283ec71107d67f4f0785ca8e51bb6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga9ca283ec71107d67f4f0785ca8e51bb6">ranges::pop_heap</a> (Rng &amp;&amp;rng, C pred=C{}, P proj=P{}) -&gt; safe_iterator_t&lt; Rng &gt; requires random_access_range&lt; Rng &gt; &amp;&amp;sortable&lt; iterator_t&lt; Rng &gt;, C, P &gt;</td></tr>
<tr class="separator:ga9ca283ec71107d67f4f0785ca8e51bb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1acfb25c2337a3d65a547c02df01da23"><td class="memTemplParams" colspan="2"><a id="ga1acfb25c2337a3d65a547c02df01da23"></a>
template&lt;typename I , typename S , typename C  = less, typename P  = identity&gt; </td></tr>
<tr class="memitem:ga1acfb25c2337a3d65a547c02df01da23"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga1acfb25c2337a3d65a547c02df01da23">ranges::prev_permutation</a> (I first, S end_, C pred=C{}, P proj=P{}) -&gt; bool requires bidirectional_iterator&lt; I &gt; &amp;&amp;sentinel_for&lt; S, I &gt; &amp;&amp;sortable&lt; I, C, P &gt;</td></tr>
<tr class="memdesc:ga1acfb25c2337a3d65a547c02df01da23"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>prev_permutation</code> <br /></td></tr>
<tr class="separator:ga1acfb25c2337a3d65a547c02df01da23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98298bd4c8bb759413d3f668a4eeaa99"><td class="memTemplParams" colspan="2">template&lt;typename Rng , typename C  = less, typename P  = identity&gt; </td></tr>
<tr class="memitem:ga98298bd4c8bb759413d3f668a4eeaa99"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga98298bd4c8bb759413d3f668a4eeaa99">ranges::prev_permutation</a> (Rng &amp;&amp;rng, C pred=C{}, P proj=P{}) -&gt; bool requires bidirectional_range&lt; Rng &gt; &amp;&amp;sortable&lt; iterator_t&lt; Rng &gt;, C, P &gt;</td></tr>
<tr class="separator:ga98298bd4c8bb759413d3f668a4eeaa99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabcb67afac8afc2557a097732b088aee0"><td class="memTemplParams" colspan="2"><a id="gabcb67afac8afc2557a097732b088aee0"></a>
template&lt;typename I , typename S , typename C  = less, typename P  = identity&gt; </td></tr>
<tr class="memitem:gabcb67afac8afc2557a097732b088aee0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gabcb67afac8afc2557a097732b088aee0">ranges::push_heap</a> (I first, S last, C pred=C{}, P proj=P{}) -&gt; I requires random_access_iterator&lt; I &gt; &amp;&amp;sentinel_for&lt; S, I &gt; &amp;&amp;sortable&lt; I, C, P &gt;</td></tr>
<tr class="memdesc:gabcb67afac8afc2557a097732b088aee0"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>push_heap</code> <br /></td></tr>
<tr class="separator:gabcb67afac8afc2557a097732b088aee0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9dd789449e2d06c65de275f53a9b0e19"><td class="memTemplParams" colspan="2">template&lt;typename Rng , typename C  = less, typename P  = identity&gt; </td></tr>
<tr class="memitem:ga9dd789449e2d06c65de275f53a9b0e19"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga9dd789449e2d06c65de275f53a9b0e19">ranges::push_heap</a> (Rng &amp;&amp;rng, C pred=C{}, P proj=P{}) -&gt; safe_iterator_t&lt; Rng &gt; requires random_access_range&lt; Rng &gt; &amp;&amp;sortable&lt; iterator_t&lt; Rng &gt;, C, P &gt;</td></tr>
<tr class="separator:ga9dd789449e2d06c65de275f53a9b0e19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga462a21d6b6ab0944c28d7e44c6254058"><td class="memTemplParams" colspan="2"><a id="ga462a21d6b6ab0944c28d7e44c6254058"></a>
template&lt;typename I , typename S , typename T , typename P  = identity&gt; </td></tr>
<tr class="memitem:ga462a21d6b6ab0944c28d7e44c6254058"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga462a21d6b6ab0944c28d7e44c6254058">ranges::remove</a> (I first, S last, T const &amp;val, P proj=P{}) -&gt; I requires permutable&lt; I &gt; &amp;&amp;sentinel_for&lt; S, I &gt; &amp;&amp;indirect_relation&lt; <a class="el" href="structranges_1_1equal__to.html">equal_to</a>, projected&lt; I, P &gt;, T const * &gt;</td></tr>
<tr class="memdesc:ga462a21d6b6ab0944c28d7e44c6254058"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>remove</code> <br /></td></tr>
<tr class="separator:ga462a21d6b6ab0944c28d7e44c6254058"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga435ac9770234270704cb373f61410d84"><td class="memTemplParams" colspan="2">template&lt;typename Rng , typename T , typename P  = identity&gt; </td></tr>
<tr class="memitem:ga435ac9770234270704cb373f61410d84"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga435ac9770234270704cb373f61410d84">ranges::remove</a> (Rng &amp;&amp;rng, T const &amp;val, P proj=P{}) -&gt; safe_iterator_t&lt; Rng &gt; requires forward_range&lt; Rng &gt; &amp;&amp;permutable&lt; iterator_t&lt; Rng &gt;&gt; &amp;&amp;indirect_relation&lt; <a class="el" href="structranges_1_1equal__to.html">equal_to</a>, projected&lt; iterator_t&lt; Rng &gt;, P &gt;, T const * &gt;</td></tr>
<tr class="separator:ga435ac9770234270704cb373f61410d84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad852bad333661acffd3fd5265c95bf48"><td class="memTemplParams" colspan="2"><a id="gad852bad333661acffd3fd5265c95bf48"></a>
template&lt;typename I , typename S , typename O , typename T , typename P  = identity&gt; </td></tr>
<tr class="memitem:gad852bad333661acffd3fd5265c95bf48"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gad852bad333661acffd3fd5265c95bf48">ranges::remove_copy</a> (I first, S last, O out, T const &amp;val, P proj=P{}) -&gt; remove_copy_result&lt; I, O &gt; requires input_iterator&lt; I &gt; &amp;&amp;sentinel_for&lt; S, I &gt; &amp;&amp;weakly_incrementable&lt; O &gt; &amp;&amp;indirect_relation&lt; <a class="el" href="structranges_1_1equal__to.html">equal_to</a>, projected&lt; I, P &gt;, T const * &gt; &amp;&amp;indirectly_copyable&lt; I, O &gt;</td></tr>
<tr class="memdesc:gad852bad333661acffd3fd5265c95bf48"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>remove_copy</code> <br /></td></tr>
<tr class="separator:gad852bad333661acffd3fd5265c95bf48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1185b7f603d2a4781464b73a01e5dfa"><td class="memTemplParams" colspan="2">template&lt;typename Rng , typename O , typename T , typename P  = identity&gt; </td></tr>
<tr class="memitem:gae1185b7f603d2a4781464b73a01e5dfa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gae1185b7f603d2a4781464b73a01e5dfa">ranges::remove_copy</a> (Rng &amp;&amp;rng, O out, T const &amp;val, P proj=P{}) -&gt; remove_copy_result&lt; safe_iterator_t&lt; Rng &gt;, O &gt; requires input_range&lt; Rng &gt; &amp;&amp;weakly_incrementable&lt; O &gt; &amp;&amp;indirect_relation&lt; <a class="el" href="structranges_1_1equal__to.html">equal_to</a>, projected&lt; iterator_t&lt; Rng &gt;, P &gt;, T const * &gt; &amp;&amp;indirectly_copyable&lt; iterator_t&lt; Rng &gt;, O &gt;</td></tr>
<tr class="separator:gae1185b7f603d2a4781464b73a01e5dfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6edd5fedf64fe6447878cdb0c096b2f"><td class="memTemplParams" colspan="2"><a id="gaf6edd5fedf64fe6447878cdb0c096b2f"></a>
template&lt;typename I , typename S , typename O , typename C , typename P  = identity&gt; </td></tr>
<tr class="memitem:gaf6edd5fedf64fe6447878cdb0c096b2f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gaf6edd5fedf64fe6447878cdb0c096b2f">ranges::remove_copy_if</a> (I first, S last, O out, C pred, P proj=P{}) -&gt; remove_copy_if_result&lt; I, O &gt; requires input_iterator&lt; I &gt; &amp;&amp;sentinel_for&lt; S, I &gt; &amp;&amp;weakly_incrementable&lt; O &gt; &amp;&amp;indirect_unary_predicate&lt; C, projected&lt; I, P &gt;&gt; &amp;&amp;indirectly_copyable&lt; I, O &gt;</td></tr>
<tr class="memdesc:gaf6edd5fedf64fe6447878cdb0c096b2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>remove_copy_if</code> <br /></td></tr>
<tr class="separator:gaf6edd5fedf64fe6447878cdb0c096b2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga364855bec8817568b6acb4fa23ec653d"><td class="memTemplParams" colspan="2">template&lt;typename Rng , typename O , typename C , typename P  = identity&gt; </td></tr>
<tr class="memitem:ga364855bec8817568b6acb4fa23ec653d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga364855bec8817568b6acb4fa23ec653d">ranges::remove_copy_if</a> (Rng &amp;&amp;rng, O out, C pred, P proj=P{}) -&gt; remove_copy_if_result&lt; safe_iterator_t&lt; Rng &gt;, O &gt; requires input_range&lt; Rng &gt; &amp;&amp;weakly_incrementable&lt; O &gt; &amp;&amp;indirect_unary_predicate&lt; C, projected&lt; iterator_t&lt; Rng &gt;, P &gt;&gt; &amp;&amp;indirectly_copyable&lt; iterator_t&lt; Rng &gt;, O &gt;</td></tr>
<tr class="separator:ga364855bec8817568b6acb4fa23ec653d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5564c4ecebc4e4ae041229d891f1491"><td class="memTemplParams" colspan="2"><a id="gad5564c4ecebc4e4ae041229d891f1491"></a>
template&lt;typename I , typename S , typename C , typename P  = identity&gt; </td></tr>
<tr class="memitem:gad5564c4ecebc4e4ae041229d891f1491"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gad5564c4ecebc4e4ae041229d891f1491">ranges::remove_if</a> (I first, S last, C pred, P proj=P{}) -&gt; I requires permutable&lt; I &gt; &amp;&amp;sentinel_for&lt; S, I &gt; &amp;&amp;indirect_unary_predicate&lt; C, projected&lt; I, P &gt;&gt;</td></tr>
<tr class="memdesc:gad5564c4ecebc4e4ae041229d891f1491"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>remove_if</code> <br /></td></tr>
<tr class="separator:gad5564c4ecebc4e4ae041229d891f1491"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a9a8184903ae3931dfd31d1e2010242"><td class="memTemplParams" colspan="2">template&lt;typename Rng , typename C , typename P  = identity&gt; </td></tr>
<tr class="memitem:ga6a9a8184903ae3931dfd31d1e2010242"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga6a9a8184903ae3931dfd31d1e2010242">ranges::remove_if</a> (Rng &amp;&amp;rng, C pred, P proj=P{}) -&gt; safe_iterator_t&lt; Rng &gt; requires forward_range&lt; Rng &gt; &amp;&amp;permutable&lt; iterator_t&lt; Rng &gt;&gt; &amp;&amp;indirect_unary_predicate&lt; C, projected&lt; iterator_t&lt; Rng &gt;, P &gt;&gt;</td></tr>
<tr class="separator:ga6a9a8184903ae3931dfd31d1e2010242"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac1140f7d360d9cf66591581023ac711f"><td class="memTemplParams" colspan="2"><a id="gac1140f7d360d9cf66591581023ac711f"></a>
template&lt;typename I , typename S , typename T1 , typename T2 , typename P  = identity&gt; </td></tr>
<tr class="memitem:gac1140f7d360d9cf66591581023ac711f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gac1140f7d360d9cf66591581023ac711f">ranges::replace</a> (I first, S last, T1 const &amp;old_value, T2 const &amp;new_value, P proj={}) -&gt; I requires input_iterator&lt; I &gt; &amp;&amp;sentinel_for&lt; S, I &gt; &amp;&amp;writable&lt; I, T2 const &amp; &gt; &amp;&amp;indirect_relation&lt; <a class="el" href="structranges_1_1equal__to.html">equal_to</a>, projected&lt; I, P &gt;, T1 const * &gt;</td></tr>
<tr class="memdesc:gac1140f7d360d9cf66591581023ac711f"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>replace</code> <br /></td></tr>
<tr class="separator:gac1140f7d360d9cf66591581023ac711f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad7acb64bbafb73fecf3cb8e598d80c3e"><td class="memTemplParams" colspan="2">template&lt;typename Rng , typename T1 , typename T2 , typename P  = identity&gt; </td></tr>
<tr class="memitem:gad7acb64bbafb73fecf3cb8e598d80c3e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gad7acb64bbafb73fecf3cb8e598d80c3e">ranges::replace</a> (Rng &amp;&amp;rng, T1 const &amp;old_value, T2 const &amp;new_value, P proj={}) -&gt; safe_iterator_t&lt; Rng &gt; requires input_range&lt; Rng &gt; &amp;&amp;writable&lt; iterator_t&lt; Rng &gt;, T2 const &amp; &gt; &amp;&amp;indirect_relation&lt; <a class="el" href="structranges_1_1equal__to.html">equal_to</a>, projected&lt; iterator_t&lt; Rng &gt;, P &gt;, T1 const * &gt;</td></tr>
<tr class="separator:gad7acb64bbafb73fecf3cb8e598d80c3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c5a843b7663cfd1bd361b9dfaefaf01"><td class="memTemplParams" colspan="2"><a id="ga4c5a843b7663cfd1bd361b9dfaefaf01"></a>
template&lt;typename I , typename S , typename O , typename T1 , typename T2 , typename P  = identity&gt; </td></tr>
<tr class="memitem:ga4c5a843b7663cfd1bd361b9dfaefaf01"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga4c5a843b7663cfd1bd361b9dfaefaf01">ranges::replace_copy</a> (I first, S last, O out, T1 const &amp;old_value, T2 const &amp;new_value, P proj={}) -&gt; replace_copy_result&lt; I, O &gt; requires input_iterator&lt; I &gt; &amp;&amp;sentinel_for&lt; S, I &gt; &amp;&amp;output_iterator&lt; O, T2 const &amp; &gt; &amp;&amp;indirectly_copyable&lt; I, O &gt; &amp;&amp;indirect_relation&lt; <a class="el" href="structranges_1_1equal__to.html">equal_to</a>, projected&lt; I, P &gt;, T1 const * &gt;</td></tr>
<tr class="memdesc:ga4c5a843b7663cfd1bd361b9dfaefaf01"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>replace_copy</code> <br /></td></tr>
<tr class="separator:ga4c5a843b7663cfd1bd361b9dfaefaf01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5f7293875320edb639082858cc6dcd3"><td class="memTemplParams" colspan="2">template&lt;typename Rng , typename O , typename T1 , typename T2 , typename P  = identity&gt; </td></tr>
<tr class="memitem:gaa5f7293875320edb639082858cc6dcd3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gaa5f7293875320edb639082858cc6dcd3">ranges::replace_copy</a> (Rng &amp;&amp;rng, O out, T1 const &amp;old_value, T2 const &amp;new_value, P proj={}) -&gt; replace_copy_result&lt; safe_iterator_t&lt; Rng &gt;, O &gt; requires input_range&lt; Rng &gt; &amp;&amp;output_iterator&lt; O, T2 const &amp; &gt; &amp;&amp;indirectly_copyable&lt; iterator_t&lt; Rng &gt;, O &gt; &amp;&amp;indirect_relation&lt; <a class="el" href="structranges_1_1equal__to.html">equal_to</a>, projected&lt; iterator_t&lt; Rng &gt;, P &gt;, T1 const * &gt;</td></tr>
<tr class="separator:gaa5f7293875320edb639082858cc6dcd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e14db878b4262fc18acf0571712c6f2"><td class="memTemplParams" colspan="2"><a id="ga8e14db878b4262fc18acf0571712c6f2"></a>
template&lt;typename I , typename S , typename O , typename C , typename T , typename P  = identity&gt; </td></tr>
<tr class="memitem:ga8e14db878b4262fc18acf0571712c6f2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga8e14db878b4262fc18acf0571712c6f2">ranges::replace_copy_if</a> (I first, S last, O out, C pred, T const &amp;new_value, P proj={}) -&gt; replace_copy_if_result&lt; I, O &gt; requires input_iterator&lt; I &gt; &amp;&amp;sentinel_for&lt; S, I &gt; &amp;&amp;output_iterator&lt; O, T const &amp; &gt; &amp;&amp;indirect_unary_predicate&lt; C, projected&lt; I, P &gt;&gt; &amp;&amp;indirectly_copyable&lt; I, O &gt;</td></tr>
<tr class="memdesc:ga8e14db878b4262fc18acf0571712c6f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>replace_copy_if</code> <br /></td></tr>
<tr class="separator:ga8e14db878b4262fc18acf0571712c6f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa27a8faf224a76ed63fd5cf5cdd7b529"><td class="memTemplParams" colspan="2">template&lt;typename Rng , typename O , typename C , typename T , typename P  = identity&gt; </td></tr>
<tr class="memitem:gaa27a8faf224a76ed63fd5cf5cdd7b529"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gaa27a8faf224a76ed63fd5cf5cdd7b529">ranges::replace_copy_if</a> (Rng &amp;&amp;rng, O out, C pred, T const &amp;new_value, P proj={}) -&gt; replace_copy_if_result&lt; safe_iterator_t&lt; Rng &gt;, O &gt; requires input_range&lt; Rng &gt; &amp;&amp;output_iterator&lt; O, T const &amp; &gt; &amp;&amp;indirect_unary_predicate&lt; C, projected&lt; iterator_t&lt; Rng &gt;, P &gt;&gt; &amp;&amp;indirectly_copyable&lt; iterator_t&lt; Rng &gt;, O &gt;</td></tr>
<tr class="separator:gaa27a8faf224a76ed63fd5cf5cdd7b529"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84410ac06ba27a46c99e2f1dc752741e"><td class="memTemplParams" colspan="2"><a id="ga84410ac06ba27a46c99e2f1dc752741e"></a>
template&lt;typename I , typename S , typename C , typename T , typename P  = identity&gt; </td></tr>
<tr class="memitem:ga84410ac06ba27a46c99e2f1dc752741e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga84410ac06ba27a46c99e2f1dc752741e">ranges::replace_if</a> (I first, S last, C pred, T const &amp;new_value, P proj=P{}) -&gt; I requires input_iterator&lt; I &gt; &amp;&amp;sentinel_for&lt; S, I &gt; &amp;&amp;indirect_unary_predicate&lt; C, projected&lt; I, P &gt;&gt; &amp;&amp;writable&lt; I, T const &amp; &gt;</td></tr>
<tr class="memdesc:ga84410ac06ba27a46c99e2f1dc752741e"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>replace_if</code> <br /></td></tr>
<tr class="separator:ga84410ac06ba27a46c99e2f1dc752741e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e329647d31be5cae926743c52380549"><td class="memTemplParams" colspan="2">template&lt;typename Rng , typename C , typename T , typename P  = identity&gt; </td></tr>
<tr class="memitem:ga2e329647d31be5cae926743c52380549"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga2e329647d31be5cae926743c52380549">ranges::replace_if</a> (Rng &amp;&amp;rng, C pred, T const &amp;new_value, P proj=P{}) -&gt; safe_iterator_t&lt; Rng &gt; requires input_range&lt; Rng &gt; &amp;&amp;indirect_unary_predicate&lt; C, projected&lt; iterator_t&lt; Rng &gt;, P &gt;&gt; &amp;&amp;writable&lt; iterator_t&lt; Rng &gt;, T const &amp; &gt;</td></tr>
<tr class="separator:ga2e329647d31be5cae926743c52380549"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4e7367f9ada77b30e1d862bea3d7f31"><td class="memTemplParams" colspan="2"><a id="gaf4e7367f9ada77b30e1d862bea3d7f31"></a>
template&lt;typename I , typename S &gt; </td></tr>
<tr class="memitem:gaf4e7367f9ada77b30e1d862bea3d7f31"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gaf4e7367f9ada77b30e1d862bea3d7f31">ranges::reverse</a> (I first, S end_) -&gt; I requires bidirectional_iterator&lt; I &gt; &amp;&amp;sentinel_for&lt; S, I &gt; &amp;&amp;permutable&lt; I &gt;</td></tr>
<tr class="memdesc:gaf4e7367f9ada77b30e1d862bea3d7f31"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>reverse</code> <br /></td></tr>
<tr class="separator:gaf4e7367f9ada77b30e1d862bea3d7f31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga351313cbb0a065290520980cbc66a629"><td class="memTemplParams" colspan="2">template&lt;typename Rng , typename I  = iterator_t&lt;Rng&gt;&gt; </td></tr>
<tr class="memitem:ga351313cbb0a065290520980cbc66a629"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga351313cbb0a065290520980cbc66a629">ranges::reverse</a> (Rng &amp;&amp;rng) -&gt; safe_iterator_t&lt; Rng &gt; requires bidirectional_range&lt; Rng &gt; &amp;&amp;permutable&lt; I &gt;</td></tr>
<tr class="separator:ga351313cbb0a065290520980cbc66a629"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa95b6255399b071291d37ab727afe2a0"><td class="memTemplParams" colspan="2"><a id="gaa95b6255399b071291d37ab727afe2a0"></a>
template&lt;typename I , typename S , typename O &gt; </td></tr>
<tr class="memitem:gaa95b6255399b071291d37ab727afe2a0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gaa95b6255399b071291d37ab727afe2a0">ranges::reverse_copy</a> (I first, S end_, O out) -&gt; reverse_copy_result&lt; I, O &gt; requires bidirectional_iterator&lt; I &gt; &amp;&amp;sentinel_for&lt; S, I &gt; &amp;&amp;weakly_incrementable&lt; O &gt; &amp;&amp;indirectly_copyable&lt; I, O &gt;</td></tr>
<tr class="memdesc:gaa95b6255399b071291d37ab727afe2a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>reverse_copy</code> <br /></td></tr>
<tr class="separator:gaa95b6255399b071291d37ab727afe2a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga483df5fd74ee979c205476aa7f3c0959"><td class="memTemplParams" colspan="2">template&lt;typename Rng , typename O &gt; </td></tr>
<tr class="memitem:ga483df5fd74ee979c205476aa7f3c0959"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga483df5fd74ee979c205476aa7f3c0959">ranges::reverse_copy</a> (Rng &amp;&amp;rng, O out) -&gt; reverse_copy_result&lt; safe_iterator_t&lt; Rng &gt;, O &gt; requires bidirectional_range&lt; Rng &gt; &amp;&amp;weakly_incrementable&lt; O &gt; &amp;&amp;indirectly_copyable&lt; iterator_t&lt; Rng &gt;, O &gt;</td></tr>
<tr class="separator:ga483df5fd74ee979c205476aa7f3c0959"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d5a4ef6209b296cd606c87895c54657"><td class="memTemplParams" colspan="2"><a id="ga3d5a4ef6209b296cd606c87895c54657"></a>
template&lt;typename I , typename S &gt; </td></tr>
<tr class="memitem:ga3d5a4ef6209b296cd606c87895c54657"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga3d5a4ef6209b296cd606c87895c54657">ranges::rotate</a> (I first, I middle, S last) -&gt; <a class="el" href="structranges_1_1subrange.html">subrange</a>&lt; I &gt; requires permutable&lt; I &gt; &amp;&amp;sentinel_for&lt; S, I &gt;</td></tr>
<tr class="memdesc:ga3d5a4ef6209b296cd606c87895c54657"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>rotate</code> <br /></td></tr>
<tr class="separator:ga3d5a4ef6209b296cd606c87895c54657"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c51098540de4beed710f73f4f2836d8"><td class="memTemplParams" colspan="2">template&lt;typename Rng , typename I  = iterator_t&lt;Rng&gt;&gt; </td></tr>
<tr class="memitem:ga0c51098540de4beed710f73f4f2836d8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga0c51098540de4beed710f73f4f2836d8">ranges::rotate</a> (Rng &amp;&amp;rng, I middle) -&gt; safe_subrange_t&lt; Rng &gt; requires range&lt; Rng &gt; &amp;&amp;permutable&lt; I &gt;</td></tr>
<tr class="separator:ga0c51098540de4beed710f73f4f2836d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2bcfab92e3c9b98eaf1bab6ce9b46306"><td class="memTemplParams" colspan="2"><a id="ga2bcfab92e3c9b98eaf1bab6ce9b46306"></a>
template&lt;typename I , typename S , typename O , typename P  = identity&gt; </td></tr>
<tr class="memitem:ga2bcfab92e3c9b98eaf1bab6ce9b46306"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga2bcfab92e3c9b98eaf1bab6ce9b46306">ranges::rotate_copy</a> (I first, I middle, S last, O out) -&gt; rotate_copy_result&lt; I, O &gt; requires forward_iterator&lt; I &gt; &amp;&amp;sentinel_for&lt; S, I &gt; &amp;&amp;weakly_incrementable&lt; O &gt; &amp;&amp;indirectly_copyable&lt; I, O &gt;</td></tr>
<tr class="memdesc:ga2bcfab92e3c9b98eaf1bab6ce9b46306"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>rotate_copy</code> <br /></td></tr>
<tr class="separator:ga2bcfab92e3c9b98eaf1bab6ce9b46306"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21b4b5a3e7ce0553270a6bb5e1b86dbd"><td class="memTemplParams" colspan="2">template&lt;typename Rng , typename O , typename P  = identity&gt; </td></tr>
<tr class="memitem:ga21b4b5a3e7ce0553270a6bb5e1b86dbd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga21b4b5a3e7ce0553270a6bb5e1b86dbd">ranges::rotate_copy</a> (Rng &amp;&amp;rng, iterator_t&lt; Rng &gt; middle, O out) -&gt; rotate_copy_result&lt; safe_iterator_t&lt; Rng &gt;, O &gt; requires range&lt; Rng &gt; &amp;&amp;weakly_incrementable&lt; O &gt; &amp;&amp;indirectly_copyable&lt; iterator_t&lt; Rng &gt;, O &gt;</td></tr>
<tr class="separator:ga21b4b5a3e7ce0553270a6bb5e1b86dbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ba2307e528141f69de2d92e3c878eee"><td class="memTemplParams" colspan="2"><a id="ga0ba2307e528141f69de2d92e3c878eee"></a>
template&lt;typename I , typename S , typename O , typename Gen  = detail::default_random_engine &amp;&gt; </td></tr>
<tr class="memitem:ga0ba2307e528141f69de2d92e3c878eee"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga0ba2307e528141f69de2d92e3c878eee">ranges::sample</a> (I first, S last, O out, iter_difference_t&lt; O &gt; const n, Gen &amp;&amp;gen=detail::get_random_engine()) -&gt; sample_result&lt; I, O &gt; requires input_iterator&lt; I &gt; &amp;&amp;sentinel_for&lt; S, I &gt; &amp;&amp;weakly_incrementable&lt; O &gt; &amp;&amp;indirectly_copyable&lt; I, O &gt; &amp;&amp;uniform_random_bit_generator&lt; std::remove_reference_t&lt; Gen &gt;&gt; &amp;&amp;(random_access_iterator&lt; O &gt;||forward_iterator&lt; I &gt;||sized_sentinel_for&lt; S, I &gt;)</td></tr>
<tr class="memdesc:ga0ba2307e528141f69de2d92e3c878eee"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>sample</code> <br /></td></tr>
<tr class="separator:ga0ba2307e528141f69de2d92e3c878eee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga192ae87a73afdb587d4d4f58066ce0b3"><td class="memTemplParams" colspan="2">template&lt;typename I , typename S , typename ORng , typename Gen  = detail::default_random_engine &amp;&gt; </td></tr>
<tr class="memitem:ga192ae87a73afdb587d4d4f58066ce0b3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga192ae87a73afdb587d4d4f58066ce0b3">ranges::sample</a> (I first, S last, ORng &amp;&amp;out, Gen &amp;&amp;gen=detail::get_random_engine()) -&gt; sample_result&lt; I, safe_iterator_t&lt; ORng &gt;&gt; requires input_iterator&lt; I &gt; &amp;&amp;sentinel_for&lt; S, I &gt; &amp;&amp;weakly_incrementable&lt; iterator_t&lt; ORng &gt;&gt; &amp;&amp;indirectly_copyable&lt; I, iterator_t&lt; ORng &gt;&gt; &amp;&amp;uniform_random_bit_generator&lt; std::remove_reference_t&lt; Gen &gt;&gt; &amp;&amp;(forward_range&lt; ORng &gt;||sized_range&lt; ORng &gt;)&amp;&amp;(random_access_iterator&lt; iterator_t&lt; ORng &gt;&gt;||forward_iterator&lt; I &gt;||sized_sentinel_for&lt; S, I &gt;)</td></tr>
<tr class="separator:ga192ae87a73afdb587d4d4f58066ce0b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6699f9e02f0ebcb00a92417eccf6725c"><td class="memTemplParams" colspan="2">template&lt;typename Rng , typename O , typename Gen  = detail::default_random_engine &amp;&gt; </td></tr>
<tr class="memitem:ga6699f9e02f0ebcb00a92417eccf6725c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga6699f9e02f0ebcb00a92417eccf6725c">ranges::sample</a> (Rng &amp;&amp;rng, O out, iter_difference_t&lt; O &gt; const n, Gen &amp;&amp;gen=detail::get_random_engine()) -&gt; sample_result&lt; safe_iterator_t&lt; Rng &gt;, O &gt; requires input_range&lt; Rng &gt; &amp;&amp;weakly_incrementable&lt; O &gt; &amp;&amp;indirectly_copyable&lt; iterator_t&lt; Rng &gt;, O &gt; &amp;&amp;uniform_random_bit_generator&lt; std::remove_reference_t&lt; Gen &gt;&gt; &amp;&amp;(random_access_iterator&lt; O &gt;||forward_range&lt; Rng &gt;||sized_range&lt; Rng &gt;)</td></tr>
<tr class="separator:ga6699f9e02f0ebcb00a92417eccf6725c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc045be30e4c526e3139fc9437082d3b"><td class="memTemplParams" colspan="2">template&lt;typename IRng , typename ORng , typename Gen  = detail::default_random_engine &amp;&gt; </td></tr>
<tr class="memitem:gadc045be30e4c526e3139fc9437082d3b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gadc045be30e4c526e3139fc9437082d3b">ranges::sample</a> (IRng &amp;&amp;rng, ORng &amp;&amp;out, Gen &amp;&amp;gen=detail::get_random_engine()) -&gt; sample_result&lt; safe_iterator_t&lt; IRng &gt;, safe_iterator_t&lt; ORng &gt;&gt; requires input_range&lt; IRng &gt; &amp;&amp;range&lt; ORng &gt; &amp;&amp;indirectly_copyable&lt; iterator_t&lt; IRng &gt;, iterator_t&lt; ORng &gt;&gt; &amp;&amp;uniform_random_bit_generator&lt; std::remove_reference_t&lt; Gen &gt;&gt; &amp;&amp;(random_access_iterator&lt; iterator_t&lt; ORng &gt;&gt;||forward_range&lt; IRng &gt;||sized_range&lt; IRng &gt;)&amp;&amp;(forward_range&lt; ORng &gt;||sized_range&lt; ORng &gt;)</td></tr>
<tr class="separator:gadc045be30e4c526e3139fc9437082d3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7be68b3cba4f31a87b846ca0c67bbcd5"><td class="memTemplParams" colspan="2"><a id="ga7be68b3cba4f31a87b846ca0c67bbcd5"></a>
template&lt;typename I1 , typename S1 , typename I2 , typename S2 , typename C  = equal_to, typename P1  = identity, typename P2  = identity&gt; </td></tr>
<tr class="memitem:ga7be68b3cba4f31a87b846ca0c67bbcd5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga7be68b3cba4f31a87b846ca0c67bbcd5">ranges::search</a> (I1 begin1, S1 end1, I2 begin2, S2 end2, C pred=C{}, P1 proj1=P1{}, P2 proj2=P2{}) -&gt; <a class="el" href="structranges_1_1subrange.html">subrange</a>&lt; I1 &gt; requires forward_iterator&lt; I1 &gt; &amp;&amp;sentinel_for&lt; S1, I1 &gt; &amp;&amp;forward_iterator&lt; I2 &gt; &amp;&amp;sentinel_for&lt; S2, I2 &gt; &amp;&amp;indirectly_comparable&lt; I1, I2, C, P1, P2 &gt;</td></tr>
<tr class="memdesc:ga7be68b3cba4f31a87b846ca0c67bbcd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>search</code> <br /></td></tr>
<tr class="separator:ga7be68b3cba4f31a87b846ca0c67bbcd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29228b9cd4dadf9e2d1e335d9d24b0b7"><td class="memTemplParams" colspan="2">template&lt;typename Rng1 , typename Rng2 , typename C  = equal_to, typename P1  = identity, typename P2  = identity&gt; </td></tr>
<tr class="memitem:ga29228b9cd4dadf9e2d1e335d9d24b0b7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga29228b9cd4dadf9e2d1e335d9d24b0b7">ranges::search</a> (Rng1 &amp;&amp;rng1, Rng2 &amp;&amp;rng2, C pred=C{}, P1 proj1=P1{}, P2 proj2=P2{}) -&gt; safe_subrange_t&lt; Rng1 &gt; requires forward_range&lt; Rng1 &gt; &amp;&amp;forward_range&lt; Rng2 &gt; &amp;&amp;indirectly_comparable&lt; iterator_t&lt; Rng1 &gt;, iterator_t&lt; Rng2 &gt;, C, P1, P2 &gt;</td></tr>
<tr class="separator:ga29228b9cd4dadf9e2d1e335d9d24b0b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5836a34415b141e5fd23499107ff30f8"><td class="memTemplParams" colspan="2"><a id="ga5836a34415b141e5fd23499107ff30f8"></a>
template&lt;typename I , typename S , typename V , typename C  = equal_to, typename P  = identity&gt; </td></tr>
<tr class="memitem:ga5836a34415b141e5fd23499107ff30f8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga5836a34415b141e5fd23499107ff30f8">ranges::search_n</a> (I first, S last, iter_difference_t&lt; I &gt; cnt, V const &amp;val, C pred=C{}, P proj=P{}) -&gt; <a class="el" href="structranges_1_1subrange.html">subrange</a>&lt; I &gt; requires forward_iterator&lt; I &gt; &amp;&amp;sentinel_for&lt; S, I &gt; &amp;&amp;indirectly_comparable&lt; I, V const *, C, P &gt;</td></tr>
<tr class="memdesc:ga5836a34415b141e5fd23499107ff30f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>search_n</code> <br /></td></tr>
<tr class="separator:ga5836a34415b141e5fd23499107ff30f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0187451967b3403c72c0d76a49dd1a13"><td class="memTemplParams" colspan="2">template&lt;typename Rng , typename V , typename C  = equal_to, typename P  = identity&gt; </td></tr>
<tr class="memitem:ga0187451967b3403c72c0d76a49dd1a13"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga0187451967b3403c72c0d76a49dd1a13">ranges::search_n</a> (Rng &amp;&amp;rng, iter_difference_t&lt; iterator_t&lt; Rng &gt;&gt; cnt, V const &amp;val, C pred=C{}, P proj=P{}) -&gt; safe_subrange_t&lt; Rng &gt; requires forward_range&lt; Rng &gt; &amp;&amp;indirectly_comparable&lt; iterator_t&lt; Rng &gt;, V const *, C, P &gt;</td></tr>
<tr class="separator:ga0187451967b3403c72c0d76a49dd1a13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b5475438384455b8a3041db1e402d0c"><td class="memTemplParams" colspan="2"><a id="ga9b5475438384455b8a3041db1e402d0c"></a>
template&lt;typename I1 , typename S1 , typename I2 , typename S2 , typename O , typename C  = less, typename P1  = identity, typename P2  = identity&gt; </td></tr>
<tr class="memitem:ga9b5475438384455b8a3041db1e402d0c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga9b5475438384455b8a3041db1e402d0c">ranges::set_difference</a> (I1 begin1, S1 end1, I2 begin2, S2 end2, O out, C pred=C{}, P1 proj1=P1{}, P2 proj2=P2{}) -&gt; set_difference_result&lt; I1, O &gt; requires sentinel_for&lt; S1, I1 &gt; &amp;&amp;sentinel_for&lt; S2, I2 &gt; &amp;&amp;mergeable&lt; I1, I2, O, C, P1, P2 &gt;</td></tr>
<tr class="memdesc:ga9b5475438384455b8a3041db1e402d0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>set_difference</code> <br /></td></tr>
<tr class="separator:ga9b5475438384455b8a3041db1e402d0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae475cf785478cfed790cfb6c1343e43a"><td class="memTemplParams" colspan="2">template&lt;typename Rng1 , typename Rng2 , typename O , typename C  = less, typename P1  = identity, typename P2  = identity&gt; </td></tr>
<tr class="memitem:gae475cf785478cfed790cfb6c1343e43a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gae475cf785478cfed790cfb6c1343e43a">ranges::set_difference</a> (Rng1 &amp;&amp;rng1, Rng2 &amp;&amp;rng2, O out, C pred=C{}, P1 proj1=P1{}, P2 proj2=P2{}) -&gt; set_difference_result&lt; safe_iterator_t&lt; Rng1 &gt;, O &gt; requires range&lt; Rng1 &gt; &amp;&amp;range&lt; Rng2 &gt; &amp;&amp;mergeable&lt; iterator_t&lt; Rng1 &gt;, iterator_t&lt; Rng2 &gt;, O, C, P1, P2 &gt;</td></tr>
<tr class="separator:gae475cf785478cfed790cfb6c1343e43a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf67b4c645005be8d8131107c31229d7"><td class="memTemplParams" colspan="2"><a id="gabf67b4c645005be8d8131107c31229d7"></a>
template&lt;typename I1 , typename S1 , typename I2 , typename S2 , typename O , typename C  = less, typename P1  = identity, typename P2  = identity&gt; </td></tr>
<tr class="memitem:gabf67b4c645005be8d8131107c31229d7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gabf67b4c645005be8d8131107c31229d7">ranges::set_intersection</a> (I1 begin1, S1 end1, I2 begin2, S2 end2, O out, C pred=C{}, P1 proj1=P1{}, P2 proj2=P2{}) -&gt; O requires sentinel_for&lt; S1, I1 &gt; &amp;&amp;sentinel_for&lt; S2, I2 &gt; &amp;&amp;mergeable&lt; I1, I2, O, C, P1, P2 &gt;</td></tr>
<tr class="memdesc:gabf67b4c645005be8d8131107c31229d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>set_intersection</code> <br /></td></tr>
<tr class="separator:gabf67b4c645005be8d8131107c31229d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga16ff3992a9314dcf174835b3a6e05245"><td class="memTemplParams" colspan="2">template&lt;typename Rng1 , typename Rng2 , typename O , typename C  = less, typename P1  = identity, typename P2  = identity&gt; </td></tr>
<tr class="memitem:ga16ff3992a9314dcf174835b3a6e05245"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga16ff3992a9314dcf174835b3a6e05245">ranges::set_intersection</a> (Rng1 &amp;&amp;rng1, Rng2 &amp;&amp;rng2, O out, C pred=C{}, P1 proj1=P1{}, P2 proj2=P2{}) -&gt; O requires range&lt; Rng1 &gt; &amp;&amp;range&lt; Rng2 &gt; &amp;&amp;mergeable&lt; iterator_t&lt; Rng1 &gt;, iterator_t&lt; Rng2 &gt;, O, C, P1, P2 &gt;</td></tr>
<tr class="separator:ga16ff3992a9314dcf174835b3a6e05245"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88073b720c6edacdbe45c57d1300f0df"><td class="memTemplParams" colspan="2"><a id="ga88073b720c6edacdbe45c57d1300f0df"></a>
template&lt;typename I1 , typename S1 , typename I2 , typename S2 , typename O , typename C  = less, typename P1  = identity, typename P2  = identity&gt; </td></tr>
<tr class="memitem:ga88073b720c6edacdbe45c57d1300f0df"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga88073b720c6edacdbe45c57d1300f0df">ranges::set_symmetric_difference</a> (I1 begin1, S1 end1, I2 begin2, S2 end2, O out, C pred=C{}, P1 proj1=P1{}, P2 proj2=P2{}) -&gt; set_symmetric_difference_result&lt; I1, I2, O &gt; requires sentinel_for&lt; S1, I1 &gt; &amp;&amp;sentinel_for&lt; S2, I2 &gt; &amp;&amp;mergeable&lt; I1, I2, O, C, P1, P2 &gt;</td></tr>
<tr class="memdesc:ga88073b720c6edacdbe45c57d1300f0df"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>set_symmetric_difference</code> <br /></td></tr>
<tr class="separator:ga88073b720c6edacdbe45c57d1300f0df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga038044a963f0b10fc883cf57ed0b01aa"><td class="memTemplParams" colspan="2">template&lt;typename Rng1 , typename Rng2 , typename O , typename C  = less, typename P1  = identity, typename P2  = identity&gt; </td></tr>
<tr class="memitem:ga038044a963f0b10fc883cf57ed0b01aa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga038044a963f0b10fc883cf57ed0b01aa">ranges::set_symmetric_difference</a> (Rng1 &amp;&amp;rng1, Rng2 &amp;&amp;rng2, O out, C pred=C{}, P1 proj1=P1{}, P2 proj2=P2{}) -&gt; set_symmetric_difference_result&lt; safe_iterator_t&lt; Rng1 &gt;, safe_iterator_t&lt; Rng2 &gt;, O &gt; requires range&lt; Rng1 &gt; &amp;&amp;range&lt; Rng2 &gt; &amp;&amp;mergeable&lt; iterator_t&lt; Rng1 &gt;, iterator_t&lt; Rng2 &gt;, O, C, P1, P2 &gt;</td></tr>
<tr class="separator:ga038044a963f0b10fc883cf57ed0b01aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1bfb815f6677887dde1caebcae3f700c"><td class="memTemplParams" colspan="2"><a id="ga1bfb815f6677887dde1caebcae3f700c"></a>
template&lt;typename I1 , typename S1 , typename I2 , typename S2 , typename O , typename C  = less, typename P1  = identity, typename P2  = identity&gt; </td></tr>
<tr class="memitem:ga1bfb815f6677887dde1caebcae3f700c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga1bfb815f6677887dde1caebcae3f700c">ranges::set_union</a> (I1 begin1, S1 end1, I2 begin2, S2 end2, O out, C pred=C{}, P1 proj1=P1{}, P2 proj2=P2{}) -&gt; set_union_result&lt; I1, I2, O &gt; requires sentinel_for&lt; S1, I1 &gt; &amp;&amp;sentinel_for&lt; S2, I2 &gt; &amp;&amp;mergeable&lt; I1, I2, O, C, P1, P2 &gt;</td></tr>
<tr class="memdesc:ga1bfb815f6677887dde1caebcae3f700c"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>set_union</code> <br /></td></tr>
<tr class="separator:ga1bfb815f6677887dde1caebcae3f700c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb1192300ac92c87a8ff922580465e2d"><td class="memTemplParams" colspan="2">template&lt;typename Rng1 , typename Rng2 , typename O , typename C  = less, typename P1  = identity, typename P2  = identity&gt; </td></tr>
<tr class="memitem:gabb1192300ac92c87a8ff922580465e2d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gabb1192300ac92c87a8ff922580465e2d">ranges::set_union</a> (Rng1 &amp;&amp;rng1, Rng2 &amp;&amp;rng2, O out, C pred=C{}, P1 proj1=P1{}, P2 proj2=P2{}) -&gt; set_union_result&lt; safe_iterator_t&lt; Rng1 &gt;, safe_iterator_t&lt; Rng2 &gt;, O &gt; requires range&lt; Rng1 &gt; &amp;&amp;range&lt; Rng2 &gt; &amp;&amp;mergeable&lt; iterator_t&lt; Rng1 &gt;, iterator_t&lt; Rng2 &gt;, O, C, P1, P2 &gt;</td></tr>
<tr class="separator:gabb1192300ac92c87a8ff922580465e2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga37626aefc51269d5a1f28edf3993baf4"><td class="memTemplParams" colspan="2"><a id="ga37626aefc51269d5a1f28edf3993baf4"></a>
template&lt;typename I , typename S , typename Gen  = detail::default_random_engine &amp;&gt; </td></tr>
<tr class="memitem:ga37626aefc51269d5a1f28edf3993baf4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga37626aefc51269d5a1f28edf3993baf4">ranges::shuffle</a> (I const first, S const last, Gen &amp;&amp;gen=detail::get_random_engine()) -&gt; I requires random_access_iterator&lt; I &gt; &amp;&amp;sentinel_for&lt; S, I &gt; &amp;&amp;permutable&lt; I &gt; &amp;&amp;uniform_random_bit_generator&lt; std::remove_reference_t&lt; Gen &gt;&gt; &amp;&amp;convertible_to&lt; invoke_result_t&lt; Gen &amp; &gt;, iter_difference_t&lt; I &gt;&gt;</td></tr>
<tr class="memdesc:ga37626aefc51269d5a1f28edf3993baf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>shuffle</code> <br /></td></tr>
<tr class="separator:ga37626aefc51269d5a1f28edf3993baf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93fd2433ca21a7105bf67aca57c4ecad"><td class="memTemplParams" colspan="2">template&lt;typename Rng , typename Gen  = detail::default_random_engine &amp;&gt; </td></tr>
<tr class="memitem:ga93fd2433ca21a7105bf67aca57c4ecad"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga93fd2433ca21a7105bf67aca57c4ecad">ranges::shuffle</a> (Rng &amp;&amp;rng, Gen &amp;&amp;rand=detail::get_random_engine()) -&gt; safe_iterator_t&lt; Rng &gt; requires random_access_range&lt; Rng &gt; &amp;&amp;permutable&lt; iterator_t&lt; Rng &gt;&gt; &amp;&amp;uniform_random_bit_generator&lt; std::remove_reference_t&lt; Gen &gt;&gt; &amp;&amp;convertible_to&lt; invoke_result_t&lt; Gen &amp; &gt;, iter_difference_t&lt; iterator_t&lt; Rng &gt;&gt;&gt;</td></tr>
<tr class="separator:ga93fd2433ca21a7105bf67aca57c4ecad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga378358ecf6ab51d495d97b9eccdb2b95"><td class="memTemplParams" colspan="2"><a id="ga378358ecf6ab51d495d97b9eccdb2b95"></a>
template&lt;typename I , typename S , typename C  = less, typename P  = identity&gt; </td></tr>
<tr class="memitem:ga378358ecf6ab51d495d97b9eccdb2b95"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga378358ecf6ab51d495d97b9eccdb2b95">ranges::sort</a> (I first, S end_, C pred=C{}, P proj=P{}) -&gt; I requires sortable&lt; I, C, P &gt; &amp;&amp;random_access_iterator&lt; I &gt; &amp;&amp;sentinel_for&lt; S, I &gt;</td></tr>
<tr class="memdesc:ga378358ecf6ab51d495d97b9eccdb2b95"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>sort</code> <br /></td></tr>
<tr class="separator:ga378358ecf6ab51d495d97b9eccdb2b95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0fda77d6d9ad1a234b712d92c949ea37"><td class="memTemplParams" colspan="2">template&lt;typename Rng , typename C  = less, typename P  = identity&gt; </td></tr>
<tr class="memitem:ga0fda77d6d9ad1a234b712d92c949ea37"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga0fda77d6d9ad1a234b712d92c949ea37">ranges::sort</a> (Rng &amp;&amp;rng, C pred=C{}, P proj=P{}) -&gt; safe_iterator_t&lt; Rng &gt; requires sortable&lt; iterator_t&lt; Rng &gt;, C, P &gt; &amp;&amp;random_access_range&lt; Rng &gt;</td></tr>
<tr class="separator:ga0fda77d6d9ad1a234b712d92c949ea37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f567bae74c1f2600e0c95d9f3c3e15b"><td class="memTemplParams" colspan="2"><a id="ga0f567bae74c1f2600e0c95d9f3c3e15b"></a>
template&lt;typename I , typename S , typename C  = less, typename P  = identity&gt; </td></tr>
<tr class="memitem:ga0f567bae74c1f2600e0c95d9f3c3e15b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::sort_heap</b> (I first, S last, C pred=C{}, P proj=P{}) -&gt; I requires random_access_iterator&lt; I &gt; &amp;&amp;sentinel_for&lt; S, I &gt; &amp;&amp;sortable&lt; I, C, P &gt;</td></tr>
<tr class="separator:ga0f567bae74c1f2600e0c95d9f3c3e15b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e1c97c0f45dd80ed99b4d00476b78e4"><td class="memTemplParams" colspan="2"><a id="ga1e1c97c0f45dd80ed99b4d00476b78e4"></a>
template&lt;typename Rng , typename C  = less, typename P  = identity&gt; </td></tr>
<tr class="memitem:ga1e1c97c0f45dd80ed99b4d00476b78e4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::sort_heap</b> (Rng &amp;&amp;rng, C pred=C{}, P proj=P{}) -&gt; safe_iterator_t&lt; Rng &gt; requires random_access_range&lt; Rng &amp; &gt; &amp;&amp;sortable&lt; iterator_t&lt; Rng &gt;, C, P &gt;</td></tr>
<tr class="separator:ga1e1c97c0f45dd80ed99b4d00476b78e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ba9e6734e1352d4c0c5ea0f1c7ce3d1"><td class="memTemplParams" colspan="2"><a id="ga5ba9e6734e1352d4c0c5ea0f1c7ce3d1"></a>
template&lt;typename I , typename S , typename C  = less, typename P  = identity&gt; </td></tr>
<tr class="memitem:ga5ba9e6734e1352d4c0c5ea0f1c7ce3d1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga5ba9e6734e1352d4c0c5ea0f1c7ce3d1">ranges::stable_sort</a> (I first, S end_, C pred=C{}, P proj=P{}) -&gt; I requires sortable&lt; I, C, P &gt; &amp;&amp;random_access_iterator&lt; I &gt; &amp;&amp;sentinel_for&lt; S, I &gt;</td></tr>
<tr class="memdesc:ga5ba9e6734e1352d4c0c5ea0f1c7ce3d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>stable_sort</code> <br /></td></tr>
<tr class="separator:ga5ba9e6734e1352d4c0c5ea0f1c7ce3d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39738e10668ac14c55c17a554ae72a55"><td class="memTemplParams" colspan="2">template&lt;typename Rng , typename C  = less, typename P  = identity&gt; </td></tr>
<tr class="memitem:ga39738e10668ac14c55c17a554ae72a55"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga39738e10668ac14c55c17a554ae72a55">ranges::stable_sort</a> (Rng &amp;&amp;rng, C pred=C{}, P proj=P{}) -&gt; safe_iterator_t&lt; Rng &gt; requires sortable&lt; iterator_t&lt; Rng &gt;, C, P &gt; &amp;&amp;random_access_range&lt; Rng &gt;</td></tr>
<tr class="separator:ga39738e10668ac14c55c17a554ae72a55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d2e5f3567c0db685cc20290b2ca0ebe"><td class="memTemplParams" colspan="2"><a id="ga3d2e5f3567c0db685cc20290b2ca0ebe"></a>
template&lt;typename I1 , typename S1 , typename I2 , typename S2 , typename Comp  = equal_to, typename Proj1  = identity, typename Proj2  = identity&gt; </td></tr>
<tr class="memitem:ga3d2e5f3567c0db685cc20290b2ca0ebe"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga3d2e5f3567c0db685cc20290b2ca0ebe">ranges::starts_with</a> (I1 first1, S1 last1, I2 first2, S2 last2, Comp comp={}, Proj1 proj1={}, Proj2 proj2={}) -&gt; bool requires input_iterator&lt; I1 &gt; &amp;&amp;sentinel_for&lt; S1, I1 &gt; &amp;&amp;input_iterator&lt; I2 &gt; &amp;&amp;sentinel_for&lt; S2, I2 &gt; &amp;&amp;indirectly_comparable&lt; I1, I2, Comp, Proj1, Proj2 &gt;</td></tr>
<tr class="memdesc:ga3d2e5f3567c0db685cc20290b2ca0ebe"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>starts_with</code> <br /></td></tr>
<tr class="separator:ga3d2e5f3567c0db685cc20290b2ca0ebe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga762b17eda45efa20b8e7407da1d3a249"><td class="memTemplParams" colspan="2">template&lt;typename R1 , typename R2 , typename Comp  = equal_to, typename Proj1  = identity, typename Proj2  = identity&gt; </td></tr>
<tr class="memitem:ga762b17eda45efa20b8e7407da1d3a249"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga762b17eda45efa20b8e7407da1d3a249">ranges::starts_with</a> (R1 &amp;&amp;r1, R2 &amp;&amp;r2, Comp comp={}, Proj1 proj1={}, Proj2 proj2={}) -&gt; bool requires input_range&lt; R1 &gt; &amp;&amp;input_range&lt; R2 &gt; &amp;&amp;indirectly_comparable&lt; iterator_t&lt; R1 &gt;, iterator_t&lt; R2 &gt;, Comp, Proj1, Proj2 &gt;</td></tr>
<tr class="separator:ga762b17eda45efa20b8e7407da1d3a249"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad69ff7f6528c3abe5b01886a10279101"><td class="memTemplParams" colspan="2"><a id="gad69ff7f6528c3abe5b01886a10279101"></a>
template&lt;typename I1 , typename S1 , typename I2 &gt; </td></tr>
<tr class="memitem:gad69ff7f6528c3abe5b01886a10279101"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gad69ff7f6528c3abe5b01886a10279101">ranges::swap_ranges</a> (I1 begin1, S1 end1, I2 begin2) -&gt; swap_ranges_result&lt; I1, I2 &gt; requires input_iterator&lt; I1 &gt; &amp;&amp;sentinel_for&lt; S1, I1 &gt; &amp;&amp;input_iterator&lt; I2 &gt; &amp;&amp;indirectly_swappable&lt; I1, I2 &gt;</td></tr>
<tr class="memdesc:gad69ff7f6528c3abe5b01886a10279101"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>swap_ranges</code> <br /></td></tr>
<tr class="separator:gad69ff7f6528c3abe5b01886a10279101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6c5f3296682ac14499cb0e7c39348ae"><td class="memTemplParams" colspan="2">template&lt;typename I1 , typename S1 , typename I2 , typename S2 &gt; </td></tr>
<tr class="memitem:gac6c5f3296682ac14499cb0e7c39348ae"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gac6c5f3296682ac14499cb0e7c39348ae">ranges::swap_ranges</a> (I1 begin1, S1 end1, I2 begin2, S2 end2) -&gt; swap_ranges_result&lt; I1, I2 &gt; requires input_iterator&lt; I1 &gt; &amp;&amp;sentinel_for&lt; S1, I1 &gt; &amp;&amp;input_iterator&lt; I2 &gt; &amp;&amp;sentinel_for&lt; S2, I2 &gt; &amp;&amp;indirectly_swappable&lt; I1, I2 &gt;</td></tr>
<tr class="separator:gac6c5f3296682ac14499cb0e7c39348ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga22dd7bb1a1351b69fc5a7d8a0819e6be"><td class="memTemplParams" colspan="2"><a id="ga22dd7bb1a1351b69fc5a7d8a0819e6be"></a>
template&lt;typename Rng1 , typename I2_ &gt; </td></tr>
<tr class="memitem:ga22dd7bb1a1351b69fc5a7d8a0819e6be"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::swap_ranges</b> (Rng1 &amp;&amp;rng1, I2_ &amp;&amp;begin2) -&gt; swap_ranges_result&lt; iterator_t&lt; Rng1 &gt;, uncvref_t&lt; I2_ &gt;&gt; requires input_range&lt; Rng1 &gt; &amp;&amp;input_iterator&lt; uncvref_t&lt; I2_ &gt;&gt; &amp;&amp;indirectly_swappable&lt; iterator_t&lt; Rng1 &gt;, uncvref_t&lt; I2_ &gt;&gt;</td></tr>
<tr class="separator:ga22dd7bb1a1351b69fc5a7d8a0819e6be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga987eea3fde92ccaa1d11dc9bb84c4028"><td class="memTemplParams" colspan="2"><a id="ga987eea3fde92ccaa1d11dc9bb84c4028"></a>
template&lt;typename Rng1 , typename Rng2 &gt; </td></tr>
<tr class="memitem:ga987eea3fde92ccaa1d11dc9bb84c4028"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::swap_ranges</b> (Rng1 &amp;&amp;rng1, Rng2 &amp;&amp;rng2) -&gt; swap_ranges_result&lt; safe_iterator_t&lt; Rng1 &gt;, safe_iterator_t&lt; Rng2 &gt;&gt; requires input_range&lt; Rng1 &gt; &amp;&amp;input_range&lt; Rng2 &gt; &amp;&amp;indirectly_swappable&lt; iterator_t&lt; Rng1 &gt;, iterator_t&lt; Rng2 &gt;&gt;</td></tr>
<tr class="separator:ga987eea3fde92ccaa1d11dc9bb84c4028"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ec1e4a23047cb95a96b694e192490ae"><td class="memTemplParams" colspan="2"><a id="ga0ec1e4a23047cb95a96b694e192490ae"></a>
template&lt;typename I , typename S , typename O , typename F , typename P  = identity&gt; </td></tr>
<tr class="memitem:ga0ec1e4a23047cb95a96b694e192490ae"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga0ec1e4a23047cb95a96b694e192490ae">ranges::transform</a> (I first, S last, O out, F fun, P proj=P{}) -&gt; unary_transform_result&lt; I, O &gt; requires input_iterator&lt; I &gt; &amp;&amp;sentinel_for&lt; S, I &gt; &amp;&amp;weakly_incrementable&lt; O &gt; &amp;&amp;copy_constructible&lt; F &gt; &amp;&amp;writable&lt; O, indirect_result_t&lt; F &amp;, projected&lt; I, P &gt;&gt;&gt;</td></tr>
<tr class="memdesc:ga0ec1e4a23047cb95a96b694e192490ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>transform</code> <br /></td></tr>
<tr class="separator:ga0ec1e4a23047cb95a96b694e192490ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac8c39da8594063d3c568ed06deaa453d"><td class="memTemplParams" colspan="2">template&lt;typename Rng , typename O , typename F , typename P  = identity&gt; </td></tr>
<tr class="memitem:gac8c39da8594063d3c568ed06deaa453d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gac8c39da8594063d3c568ed06deaa453d">ranges::transform</a> (Rng &amp;&amp;rng, O out, F fun, P proj=P{}) -&gt; unary_transform_result&lt; safe_iterator_t&lt; Rng &gt;, O &gt; requires input_range&lt; Rng &gt; &amp;&amp;weakly_incrementable&lt; O &gt; &amp;&amp;copy_constructible&lt; F &gt; &amp;&amp;writable&lt; O, indirect_result_t&lt; F &amp;, projected&lt; iterator_t&lt; Rng &gt;, P &gt;&gt;&gt;</td></tr>
<tr class="separator:gac8c39da8594063d3c568ed06deaa453d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4ce8886b2139e524a7a55d9533ecb17"><td class="memTemplParams" colspan="2">template&lt;typename I0 , typename S0 , typename I1 , typename S1 , typename O , typename F , typename P0  = identity, typename P1  = identity&gt; </td></tr>
<tr class="memitem:gac4ce8886b2139e524a7a55d9533ecb17"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gac4ce8886b2139e524a7a55d9533ecb17">ranges::transform</a> (I0 begin0, S0 end0, I1 begin1, S1 end1, O out, F fun, P0 proj0=P0{}, P1 proj1=P1{}) -&gt; binary_transform_result&lt; I0, I1, O &gt; requires input_iterator&lt; I0 &gt; &amp;&amp;sentinel_for&lt; S0, I0 &gt; &amp;&amp;input_iterator&lt; I1 &gt; &amp;&amp;sentinel_for&lt; S1, I1 &gt; &amp;&amp;weakly_incrementable&lt; O &gt; &amp;&amp;copy_constructible&lt; F &gt; &amp;&amp;writable&lt; O, indirect_result_t&lt; F &amp;, projected&lt; I0, P0 &gt;, projected&lt; I1, P1 &gt;&gt;&gt;</td></tr>
<tr class="separator:gac4ce8886b2139e524a7a55d9533ecb17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45614e7d9ed220f702f59033a5c833db"><td class="memTemplParams" colspan="2">template&lt;typename Rng0 , typename Rng1 , typename O , typename F , typename P0  = identity, typename P1  = identity&gt; </td></tr>
<tr class="memitem:ga45614e7d9ed220f702f59033a5c833db"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga45614e7d9ed220f702f59033a5c833db">ranges::transform</a> (Rng0 &amp;&amp;rng0, Rng1 &amp;&amp;rng1, O out, F fun, P0 proj0=P0{}, P1 proj1=P1{}) -&gt; binary_transform_result&lt; safe_iterator_t&lt; Rng0 &gt;, safe_iterator_t&lt; Rng1 &gt;, O &gt; requires input_range&lt; Rng0 &gt; &amp;&amp;input_range&lt; Rng1 &gt; &amp;&amp;weakly_incrementable&lt; O &gt; &amp;&amp;copy_constructible&lt; F &gt; &amp;&amp;writable&lt; O, indirect_result_t&lt; F &amp;, projected&lt; iterator_t&lt; Rng0 &gt;, P0 &gt;, projected&lt; iterator_t&lt; Rng1 &gt;, P1 &gt;&gt;&gt;</td></tr>
<tr class="separator:ga45614e7d9ed220f702f59033a5c833db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59baf93d7a2cbaa4457120a8da5414b0"><td class="memTemplParams" colspan="2">template&lt;typename I0 , typename S0 , typename I1 , typename O , typename F , typename P0  = identity, typename P1  = identity&gt; </td></tr>
<tr class="memitem:ga59baf93d7a2cbaa4457120a8da5414b0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga59baf93d7a2cbaa4457120a8da5414b0">ranges::transform</a> (I0 begin0, S0 end0, I1 begin1, O out, F fun, P0 proj0=P0{}, P1 proj1=P1{}) -&gt; binary_transform_result&lt; I0, I1, O &gt; requires input_iterator&lt; I0 &gt; &amp;&amp;sentinel_for&lt; S0, I0 &gt; &amp;&amp;input_iterator&lt; I1 &gt; &amp;&amp;weakly_incrementable&lt; O &gt; &amp;&amp;copy_constructible&lt; F &gt; &amp;&amp;writable&lt; O, indirect_result_t&lt; F &amp;, projected&lt; I0, P0 &gt;, projected&lt; I1, P1 &gt;&gt;&gt;</td></tr>
<tr class="separator:ga59baf93d7a2cbaa4457120a8da5414b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa31831f1a06d2268c06a9a04981ed55"><td class="memTemplParams" colspan="2">template&lt;typename Rng0 , typename I1Ref , typename O , typename F , typename P0  = identity, typename P1  = identity&gt; </td></tr>
<tr class="memitem:gafa31831f1a06d2268c06a9a04981ed55"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gafa31831f1a06d2268c06a9a04981ed55">ranges::transform</a> (Rng0 &amp;&amp;rng0, I1Ref &amp;&amp;begin1, O out, F fun, P0 proj0=P0{}, P1 proj1=P1{}) -&gt; binary_transform_result&lt; safe_iterator_t&lt; Rng0 &gt;, uncvref_t&lt; I1Ref &gt;, O &gt; requires input_range&lt; Rng0 &gt; &amp;&amp;input_iterator&lt; uncvref_t&lt; I1Ref &gt;&gt; &amp;&amp;weakly_incrementable&lt; O &gt; &amp;&amp;copy_constructible&lt; F &gt; &amp;&amp;writable&lt; O, indirect_result_t&lt; F &amp;, projected&lt; iterator_t&lt; Rng0 &gt;, P0 &gt;, projected&lt; uncvref_t&lt; I1Ref &gt;, P1 &gt;&gt;&gt;</td></tr>
<tr class="separator:gafa31831f1a06d2268c06a9a04981ed55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5e540912bea57a858b704e1b663ea01"><td class="memTemplParams" colspan="2">template&lt;typename I , typename S , typename C  = equal_to, typename P  = identity&gt; </td></tr>
<tr class="memitem:gae5e540912bea57a858b704e1b663ea01"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gae5e540912bea57a858b704e1b663ea01">ranges::unique</a> (I first, S last, C pred=C{}, P proj=P{}) -&gt; I requires sortable&lt; I, C, P &gt; &amp;&amp;sentinel_for&lt; S, I &gt;</td></tr>
<tr class="memdesc:gae5e540912bea57a858b704e1b663ea01"><td class="mdescLeft">&#160;</td><td class="mdescRight">template function <code>unique</code>  <a href="group__group-algorithms.html#gae5e540912bea57a858b704e1b663ea01">More...</a><br /></td></tr>
<tr class="separator:gae5e540912bea57a858b704e1b663ea01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade22082168ffc3e0710b7181732cf979"><td class="memTemplParams" colspan="2">template&lt;typename Rng , typename C  = equal_to, typename P  = identity&gt; </td></tr>
<tr class="memitem:gade22082168ffc3e0710b7181732cf979"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gade22082168ffc3e0710b7181732cf979">ranges::unique</a> (Rng &amp;&amp;rng, C pred=C{}, P proj=P{}) -&gt; safe_iterator_t&lt; Rng &gt; requires sortable&lt; iterator_t&lt; Rng &gt;, C, P &gt; &amp;&amp;range&lt; Rng &gt;</td></tr>
<tr class="separator:gade22082168ffc3e0710b7181732cf979"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe19943e4d2efa41533b2d068dc268c4"><td class="memTemplParams" colspan="2">template&lt;typename I , typename S , typename O , typename C  = equal_to, typename P  = identity&gt; </td></tr>
<tr class="memitem:gafe19943e4d2efa41533b2d068dc268c4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gafe19943e4d2efa41533b2d068dc268c4">ranges::unique_copy</a> (I first, S last, O out, C pred=C{}, P proj=P{}) -&gt; unique_copy_result&lt; I, O &gt; requires input_iterator&lt; I &gt; &amp;&amp;sentinel_for&lt; S, I &gt; &amp;&amp;indirect_relation&lt; C, projected&lt; I, P &gt;&gt; &amp;&amp;weakly_incrementable&lt; O &gt; &amp;&amp;indirectly_copyable&lt; I, O &gt; &amp;&amp;(forward_iterator&lt; I &gt;||forward_iterator&lt; O &gt;||indirectly_copyable_storable&lt; I, O &gt;)</td></tr>
<tr class="memdesc:gafe19943e4d2efa41533b2d068dc268c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">template function unique_copy  <a href="group__group-algorithms.html#gafe19943e4d2efa41533b2d068dc268c4">More...</a><br /></td></tr>
<tr class="separator:gafe19943e4d2efa41533b2d068dc268c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4cb85c9a5ce8c5773f1f7f8fa9d6ef15"><td class="memTemplParams" colspan="2">template&lt;typename Rng , typename O , typename C  = equal_to, typename P  = identity&gt; </td></tr>
<tr class="memitem:ga4cb85c9a5ce8c5773f1f7f8fa9d6ef15"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga4cb85c9a5ce8c5773f1f7f8fa9d6ef15">ranges::unique_copy</a> (Rng &amp;&amp;rng, O out, C pred=C{}, P proj=P{}) -&gt; unique_copy_result&lt; safe_iterator_t&lt; Rng &gt;, O &gt; requires input_range&lt; Rng &gt; &amp;&amp;indirect_relation&lt; C, projected&lt; iterator_t&lt; Rng &gt;, P &gt;&gt; &amp;&amp;weakly_incrementable&lt; O &gt; &amp;&amp;indirectly_copyable&lt; iterator_t&lt; Rng &gt;, O &gt; &amp;&amp;(forward_iterator&lt; iterator_t&lt; Rng &gt;&gt;||forward_iterator&lt; O &gt;||indirectly_copyable_storable&lt; iterator_t&lt; Rng &gt;, O &gt;)</td></tr>
<tr class="separator:ga4cb85c9a5ce8c5773f1f7f8fa9d6ef15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef222b7bf5356fd2124bf661a359d730"><td class="memTemplParams" colspan="2">template&lt;typename I , typename C , typename P  = identity&gt; </td></tr>
<tr class="memitem:gaef222b7bf5356fd2124bf661a359d730"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gaef222b7bf5356fd2124bf661a359d730">ranges::unstable_remove_if</a> (I first, I last, C pred, P proj={}) -&gt; I requires bidirectional_iterator&lt; I &gt; &amp;&amp;permutable&lt; I &gt; &amp;&amp;indirect_unary_predicate&lt; C, projected&lt; I, P &gt;&gt;</td></tr>
<tr class="memdesc:gaef222b7bf5356fd2124bf661a359d730"><td class="mdescLeft">&#160;</td><td class="mdescRight">unstable_remove have O(1) complexity for each element remove, unlike remove O(n) [for worst case]. Each erased element overwritten (moved in) with last one. unstable_remove_if does not preserve relative element order.  <a href="group__group-algorithms.html#gaef222b7bf5356fd2124bf661a359d730">More...</a><br /></td></tr>
<tr class="separator:gaef222b7bf5356fd2124bf661a359d730"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93307fbcec220cfea80936970d4c8d1a"><td class="memTemplParams" colspan="2">template&lt;typename Rng , typename C , typename P  = identity&gt; </td></tr>
<tr class="memitem:ga93307fbcec220cfea80936970d4c8d1a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga93307fbcec220cfea80936970d4c8d1a">ranges::unstable_remove_if</a> (Rng &amp;&amp;rng, C pred, P proj=P{}) -&gt; safe_iterator_t&lt; Rng &gt; requires bidirectional_range&lt; Rng &gt; &amp;&amp;common_range&lt; Rng &gt; &amp;&amp;permutable&lt; iterator_t&lt; Rng &gt;&gt; &amp;&amp;indirect_unary_predicate&lt; C, projected&lt; iterator_t&lt; Rng &gt;, P &gt;&gt;</td></tr>
<tr class="separator:ga93307fbcec220cfea80936970d4c8d1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga658e864595b11296299920adeafa8a89"><td class="memTemplParams" colspan="2"><a id="ga658e864595b11296299920adeafa8a89"></a>
template&lt;typename I , typename S , typename V , typename C  = less, typename P  = identity&gt; </td></tr>
<tr class="memitem:ga658e864595b11296299920adeafa8a89"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga658e864595b11296299920adeafa8a89">ranges::upper_bound</a> (I first, S last, V const &amp;val, C pred=C{}, P proj=P{}) -&gt; I requires forward_iterator&lt; I &gt; &amp;&amp;sentinel_for&lt; S, I &gt; &amp;&amp;indirect_strict_weak_order&lt; C, V const *, projected&lt; I, P &gt;&gt;</td></tr>
<tr class="memdesc:ga658e864595b11296299920adeafa8a89"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>upper_bound</code> <br /></td></tr>
<tr class="separator:ga658e864595b11296299920adeafa8a89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1fcb1018d6953624f46428fe9956e04b"><td class="memTemplParams" colspan="2">template&lt;typename Rng , typename V , typename C  = less, typename P  = identity&gt; </td></tr>
<tr class="memitem:ga1fcb1018d6953624f46428fe9956e04b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classauto.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga1fcb1018d6953624f46428fe9956e04b">ranges::upper_bound</a> (Rng &amp;&amp;rng, V const &amp;val, C pred=C{}, P proj=P{}) -&gt; safe_iterator_t&lt; Rng &gt; requires forward_range&lt; Rng &gt; &amp;&amp;indirect_strict_weak_order&lt; C, V const *, projected&lt; iterator_t&lt; Rng &gt;, P &gt;&gt;</td></tr>
<tr class="separator:ga1fcb1018d6953624f46428fe9956e04b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga144612fc146861f9979b3e6e25268732"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga144612fc146861f9979b3e6e25268732">&#9670;&nbsp;</a></span>adjacent_find() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename S , typename C  = equal_to, typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classauto.html">auto</a> ranges::adjacent_find </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em> = <code>C{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; I   
                requires forward_iterator&lt;I&gt; &amp;&amp; sentinel_for&lt;S, I&gt; &amp;&amp;
                indirect_relation&lt;C, projected&lt;I, P&gt;&gt; 
        </td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="adjacent__find_8hpp.html">range/v3/algorithm/adjacent_find.hpp</a>&gt;</code></p>

<p>function template <code>adjacent_find</code> </p>
<p>range-based version of the <code>adjacent_find</code> std algorithm</p>
<dl class="section pre"><dt>Precondition</dt><dd><code>Rng</code> is a model of the <code>range</code> concept </dd>
<dd>
<code>C</code> is a model of the <code>BinaryPredicate</code> concept </dd></dl>

</div>
</div>
<a id="gac18173d384f683bde768744166ae5907"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac18173d384f683bde768744166ae5907">&#9670;&nbsp;</a></span>adjacent_find() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng , typename C  = equal_to, typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classauto.html">auto</a> ranges::adjacent_find </td>
          <td>(</td>
          <td class="paramtype">Rng &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em> = <code>C{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; safe_iterator_t&lt;Rng&gt;   
                requires forward_range&lt;Rng&gt; &amp;&amp;
                indirect_relation&lt;C, projected&lt;iterator_t&lt;Rng&gt;, P&gt;&gt; 
        </td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="adjacent__find_8hpp.html">range/v3/algorithm/adjacent_find.hpp</a>&gt;</code></p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="ga2d08c6a9c28092deaa0a55dfc92fd1cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2d08c6a9c28092deaa0a55dfc92fd1cd">&#9670;&nbsp;</a></span>adjacent_remove_if() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename S , typename Pred , typename Proj  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classauto.html">auto</a> ranges::adjacent_remove_if </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Pred&#160;</td>
          <td class="paramname"><em>pred</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Proj&#160;</td>
          <td class="paramname"><em>proj</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; I   
                requires permutable&lt;I&gt; &amp;&amp; sentinel_for&lt;S, I&gt; &amp;&amp;
                indirect_relation&lt;Pred, projected&lt;I, Proj&gt;&gt; 
        </td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="algorithm_2adjacent__remove__if_8hpp.html">range/v3/algorithm/adjacent_remove_if.hpp</a>&gt;</code></p>

<p>function <code>adjacent_remove_if</code> </p>
<p>range-based version of the <code>adjacent_remove_if</code> algorithm</p>
<dl class="section pre"><dt>Precondition</dt><dd><code>Rng</code> is a model of the <code>forward_range</code> concept. </dd>
<dd>
<code>Pred</code> is a model of the <code>BinaryPredicate</code> concept. </dd></dl>

</div>
</div>
<a id="ga7eb3423653bb64e8fec6c9103d0b2fd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7eb3423653bb64e8fec6c9103d0b2fd9">&#9670;&nbsp;</a></span>adjacent_remove_if() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng , typename Pred , typename Proj  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classauto.html">auto</a> ranges::adjacent_remove_if </td>
          <td>(</td>
          <td class="paramtype">Rng &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Pred&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Proj&#160;</td>
          <td class="paramname"><em>proj</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; safe_iterator_t&lt;Rng&gt;   
                requires forward_range&lt;Rng&gt; &amp;&amp;
                indirect_relation&lt;Pred, projected&lt;iterator_t&lt;Rng&gt;, Proj&gt;&gt; &amp;&amp;
                permutable&lt;iterator_t&lt;Rng&gt;&gt; 
        </td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="algorithm_2adjacent__remove__if_8hpp.html">range/v3/algorithm/adjacent_remove_if.hpp</a>&gt;</code></p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="ga264d1b1c80f6f675d5c708d9b044a7f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga264d1b1c80f6f675d5c708d9b044a7f0">&#9670;&nbsp;</a></span>all_of()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng , typename F , typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classauto.html">auto</a> ranges::all_of </td>
          <td>(</td>
          <td class="paramtype">Rng &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool   
                requires input_range&lt;Rng&gt; &amp;&amp;
                indirect_unary_predicate&lt;F, projected&lt;iterator_t&lt;Rng&gt;, P&gt;&gt; 
        </td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="all__of_8hpp.html">range/v3/algorithm/all_of.hpp</a>&gt;</code></p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="gad75b386493da30a175489379ad3d44ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad75b386493da30a175489379ad3d44ed">&#9670;&nbsp;</a></span>any_of()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng , typename F , typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classauto.html">auto</a> ranges::any_of </td>
          <td>(</td>
          <td class="paramtype">Rng &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool   
                requires input_range&lt;Rng&gt; &amp;&amp;
                indirect_unary_predicate&lt;F, projected&lt;iterator_t&lt;Rng&gt;, P&gt;&gt; 
        </td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="any__of_8hpp.html">range/v3/algorithm/any_of.hpp</a>&gt;</code></p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="ga522f7ae248b5dbfd4bf958089c30368e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga522f7ae248b5dbfd4bf958089c30368e">&#9670;&nbsp;</a></span>binary_search() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename S , typename V , typename C  = less, typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classauto.html">auto</a> ranges::binary_search </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">V const &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em> = <code>C{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool   
                requires forward_iterator&lt;I&gt; &amp;&amp; sentinel_for&lt;S, I&gt; &amp;&amp;
                indirect_strict_weak_order&lt;C, V const *, projected&lt;I, P&gt;&gt; 
        </td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="binary__search_8hpp.html">range/v3/algorithm/binary_search.hpp</a>&gt;</code></p>

<p>function template <code>binary_search</code> </p>
<p>range-based version of the <code>binary_search</code> std algorithm</p>
<dl class="section pre"><dt>Precondition</dt><dd><code>Rng</code> is a model of the <code>range</code> concept </dd></dl>

</div>
</div>
<a id="gae4f24f78b0f07cb2deca6cb3f7b01bfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae4f24f78b0f07cb2deca6cb3f7b01bfc">&#9670;&nbsp;</a></span>binary_search() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng , typename V , typename C  = less, typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classauto.html">auto</a> ranges::binary_search </td>
          <td>(</td>
          <td class="paramtype">Rng &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">V const &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em> = <code>C{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool   
                requires forward_range&lt;Rng&gt; &amp;&amp;
                indirect_strict_weak_order&lt;C, V const *, projected&lt;iterator_t&lt;Rng&gt;, P&gt;&gt; 
        </td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="binary__search_8hpp.html">range/v3/algorithm/binary_search.hpp</a>&gt;</code></p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="ga01a62ccee18d1fec2e634bb3141e8582"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga01a62ccee18d1fec2e634bb3141e8582">&#9670;&nbsp;</a></span>contains()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng , typename T , typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classauto.html">auto</a> ranges::contains </td>
          <td>(</td>
          <td class="paramtype">Rng &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool   
                requires input_range&lt;Rng&gt; &amp;&amp;
                indirect_relation&lt;<a class="el" href="structranges_1_1equal__to.html">equal_to</a>, projected&lt;iterator_t&lt;Rng&gt;, P&gt;, const T *&gt; 
        </td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="contains_8hpp.html">range/v3/algorithm/contains.hpp</a>&gt;</code></p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="ga917adb24d7ee65882cf576a5a4c5228d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga917adb24d7ee65882cf576a5a4c5228d">&#9670;&nbsp;</a></span>copy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng , typename O &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classauto.html">auto</a> ranges::copy </td>
          <td>(</td>
          <td class="paramtype">Rng &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">O&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; copy_result&lt;safe_iterator_t&lt;Rng&gt;, O&gt;   
                requires input_range&lt;Rng&gt; &amp;&amp; weakly_incrementable&lt;O&gt; &amp;&amp;
                indirectly_copyable&lt;iterator_t&lt;Rng&gt;, O&gt; 
        </td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="algorithm_2copy_8hpp.html">range/v3/algorithm/copy.hpp</a>&gt;</code></p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="ga908b242ebc91d53a3f38ce24d01493b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga908b242ebc91d53a3f38ce24d01493b1">&#9670;&nbsp;</a></span>copy_backward()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng , typename O &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classauto.html">auto</a> ranges::copy_backward </td>
          <td>(</td>
          <td class="paramtype">Rng &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">O&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; copy_backward_result&lt;safe_iterator_t&lt;Rng&gt;, O&gt;   
                requires bidirectional_range&lt;Rng&gt; &amp;&amp; bidirectional_iterator&lt;O&gt; &amp;&amp;
                indirectly_copyable&lt;iterator_t&lt;Rng&gt;, O&gt; 
        </td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="copy__backward_8hpp.html">range/v3/algorithm/copy_backward.hpp</a>&gt;</code></p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="gacf2c0297eeb25e9a6fd9d1323f4eb967"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacf2c0297eeb25e9a6fd9d1323f4eb967">&#9670;&nbsp;</a></span>copy_if()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng , typename O , typename F , typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classauto.html">auto</a> ranges::copy_if </td>
          <td>(</td>
          <td class="paramtype">Rng &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">O&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; copy_if_result&lt;safe_iterator_t&lt;Rng&gt;, O&gt;   
                requires input_range&lt;Rng&gt; &amp;&amp; weakly_incrementable&lt;O&gt; &amp;&amp;
                indirect_unary_predicate&lt;F, projected&lt;iterator_t&lt;Rng&gt;, P&gt;&gt; &amp;&amp;
                indirectly_copyable&lt;iterator_t&lt;Rng&gt;, O&gt; 
        </td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="copy__if_8hpp.html">range/v3/algorithm/copy_if.hpp</a>&gt;</code></p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="gae2ef1075d6f1f102246b50dff5e01eda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae2ef1075d6f1f102246b50dff5e01eda">&#9670;&nbsp;</a></span>count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng , typename V , typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classauto.html">auto</a> ranges::count </td>
          <td>(</td>
          <td class="paramtype">Rng &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">V const &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; iter_difference_t&lt;iterator_t&lt;Rng&gt;&gt;   
                requires input_range&lt;Rng&gt; &amp;&amp;
                indirect_relation&lt;<a class="el" href="structranges_1_1equal__to.html">equal_to</a>, projected&lt;iterator_t&lt;Rng&gt;, P&gt;, V const *&gt; 
        </td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="count_8hpp.html">range/v3/algorithm/count.hpp</a>&gt;</code></p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="ga8a066f39ca76bf1389b93ffd55720f7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8a066f39ca76bf1389b93ffd55720f7e">&#9670;&nbsp;</a></span>count_if()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng , typename R , typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classauto.html">auto</a> ranges::count_if </td>
          <td>(</td>
          <td class="paramtype">Rng &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; iter_difference_t&lt;iterator_t&lt;Rng&gt;&gt;   
                requires input_range&lt;Rng&gt; &amp;&amp;
                indirect_unary_predicate&lt;R, projected&lt;iterator_t&lt;Rng&gt;, P&gt;&gt; 
        </td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="count__if_8hpp.html">range/v3/algorithm/count_if.hpp</a>&gt;</code></p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="ga153b08aa10efdd1745b55a66dff7aa65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga153b08aa10efdd1745b55a66dff7aa65">&#9670;&nbsp;</a></span>ends_with()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng0 , typename Rng1 , typename C  = equal_to, typename P0  = identity, typename P1  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classauto.html">auto</a> ranges::ends_with </td>
          <td>(</td>
          <td class="paramtype">Rng0 &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Rng1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em> = <code>C{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P0&#160;</td>
          <td class="paramname"><em>proj0</em> = <code>P0{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P1&#160;</td>
          <td class="paramname"><em>proj1</em> = <code>P1{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool   
                requires(forward_range&lt;Rng0&gt; ||
                         (input_range&lt;Rng0&gt; &amp;&amp; sized_range&lt;Rng0&gt;)) &amp;&amp;
                (forward_range&lt;Rng1&gt; || (input_range&lt;Rng1&gt; &amp;&amp; sized_range&lt;Rng1&gt;)) &amp;&amp;
                indirectly_comparable&lt;iterator_t&lt;Rng0&gt;, iterator_t&lt;Rng1&gt;, C, P0, P1&gt; 
        </td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="ends__with_8hpp.html">range/v3/algorithm/ends_with.hpp</a>&gt;</code></p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="gaf7135f2a482e12c3d97d77c3e13937eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf7135f2a482e12c3d97d77c3e13937eb">&#9670;&nbsp;</a></span>equal() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I0 , typename S0 , typename I1 , typename S1 , typename C  = equal_to, typename P0  = identity, typename P1  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classauto.html">auto</a> ranges::equal </td>
          <td>(</td>
          <td class="paramtype">I0&#160;</td>
          <td class="paramname"><em>begin0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S0&#160;</td>
          <td class="paramname"><em>end0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I1&#160;</td>
          <td class="paramname"><em>begin1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S1&#160;</td>
          <td class="paramname"><em>end1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em> = <code>C{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P0&#160;</td>
          <td class="paramname"><em>proj0</em> = <code>P0{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P1&#160;</td>
          <td class="paramname"><em>proj1</em> = <code>P1{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool   
                requires input_iterator&lt;I0&gt; &amp;&amp; sentinel_for&lt;S0, I0&gt; &amp;&amp;
                input_iterator&lt;I1&gt; &amp;&amp; sentinel_for&lt;S1, I1&gt; &amp;&amp;
                indirectly_comparable&lt;I0, I1, C, P0, P1&gt; 
        </td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="equal_8hpp.html">range/v3/algorithm/equal.hpp</a>&gt;</code></p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="ga4bb144928dd7fc7c4004bde7b8b5240e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4bb144928dd7fc7c4004bde7b8b5240e">&#9670;&nbsp;</a></span>equal() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng0 , typename I1Ref , typename C  = equal_to, typename P0  = identity, typename P1  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classauto.html">auto</a> ranges::equal </td>
          <td>(</td>
          <td class="paramtype">Rng0 &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I1Ref &amp;&amp;&#160;</td>
          <td class="paramname"><em>begin1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em> = <code>C{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P0&#160;</td>
          <td class="paramname"><em>proj0</em> = <code>P0{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P1&#160;</td>
          <td class="paramname"><em>proj1</em> = <code>P1{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool   
                requires input_range&lt;Rng0&gt; &amp;&amp; input_iterator&lt;uncvref_t&lt;I1Ref&gt;&gt; &amp;&amp;
                indirectly_comparable&lt;iterator_t&lt;Rng0&gt;, uncvref_t&lt;I1Ref&gt;, C, P0, P1&gt; 
        </td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="equal_8hpp.html">range/v3/algorithm/equal.hpp</a>&gt;</code></p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="gacd9f750063e371826d0d82e81c5d825e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacd9f750063e371826d0d82e81c5d825e">&#9670;&nbsp;</a></span>equal() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng0 , typename Rng1 , typename C  = equal_to, typename P0  = identity, typename P1  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classauto.html">auto</a> ranges::equal </td>
          <td>(</td>
          <td class="paramtype">Rng0 &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Rng1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em> = <code>C{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P0&#160;</td>
          <td class="paramname"><em>proj0</em> = <code>P0{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P1&#160;</td>
          <td class="paramname"><em>proj1</em> = <code>P1{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool   
                requires input_range&lt;Rng0&gt; &amp;&amp; input_range&lt;Rng1&gt; &amp;&amp;
                indirectly_comparable&lt;iterator_t&lt;Rng0&gt;, iterator_t&lt;Rng1&gt;, C, P0, P1&gt; 
        </td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="equal_8hpp.html">range/v3/algorithm/equal.hpp</a>&gt;</code></p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="gab6bb9cf9ee4851960191848e5fc1a34e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab6bb9cf9ee4851960191848e5fc1a34e">&#9670;&nbsp;</a></span>equal_range()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng , typename V , typename C  = less, typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classauto.html">auto</a> ranges::equal_range </td>
          <td>(</td>
          <td class="paramtype">Rng &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">V const &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em> = <code>C{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; safe_subrange_t&lt;Rng&gt;   
                requires forward_range&lt;Rng&gt; &amp;&amp;
                indirect_strict_weak_order&lt;C, V const *, projected&lt;iterator_t&lt;Rng&gt;, P&gt;&gt; 
        </td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="equal__range_8hpp.html">range/v3/algorithm/equal_range.hpp</a>&gt;</code></p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="ga1250c1c363e349a985a2b3b89a31f7fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1250c1c363e349a985a2b3b89a31f7fa">&#9670;&nbsp;</a></span>fill()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng , typename V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classauto.html">auto</a> ranges::fill </td>
          <td>(</td>
          <td class="paramtype">Rng &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">V const &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; safe_iterator_t&lt;Rng&gt;   
                requires output_range&lt;Rng, V const &amp;&gt; 
        </td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="fill_8hpp.html">range/v3/algorithm/fill.hpp</a>&gt;</code></p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="gaa0c8dbb38d3d49a554898eea469baee7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa0c8dbb38d3d49a554898eea469baee7">&#9670;&nbsp;</a></span>find() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename S , typename V , typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classauto.html">auto</a> ranges::find </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">V const &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; I   
                requires input_iterator&lt;I&gt; &amp;&amp; sentinel_for&lt;S, I&gt; &amp;&amp;
                indirect_relation&lt;<a class="el" href="structranges_1_1equal__to.html">equal_to</a>, projected&lt;I, P&gt;, V const *&gt; 
        </td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="find_8hpp.html">range/v3/algorithm/find.hpp</a>&gt;</code></p>

<p>template function <code>find</code> </p>
<p>range-based version of the <code>find</code> std algorithm</p>
<dl class="section pre"><dt>Precondition</dt><dd><code>Rng</code> is a model of the <code>range</code> concept </dd>
<dd>
<code>I</code> is a model of the <code>input_iterator</code> concept </dd>
<dd>
<code>S</code> is a model of the <code>sentinel_for&lt;I&gt;</code> concept </dd>
<dd>
<code>P</code> is a model of the <code>invocable&lt;iter_common_reference_t&lt;I&gt;&gt;</code> concept </dd>
<dd>
The ResultType of <code>P</code> is equality_comparable with V </dd></dl>

</div>
</div>
<a id="ga1fdffc553245eb3c303eaff6e178bf70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1fdffc553245eb3c303eaff6e178bf70">&#9670;&nbsp;</a></span>find() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng , typename V , typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classauto.html">auto</a> ranges::find </td>
          <td>(</td>
          <td class="paramtype">Rng &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">V const &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; safe_iterator_t&lt;Rng&gt;   
                requires input_range&lt;Rng&gt; &amp;&amp;
                indirect_relation&lt;<a class="el" href="structranges_1_1equal__to.html">equal_to</a>, projected&lt;iterator_t&lt;Rng&gt;, P&gt;, V const *&gt; 
        </td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="find_8hpp.html">range/v3/algorithm/find.hpp</a>&gt;</code></p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="gab12f25e857f8d8468ec5955b4956f503"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab12f25e857f8d8468ec5955b4956f503">&#9670;&nbsp;</a></span>find_end()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng1 , typename Rng2 , typename R  = equal_to, typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classauto.html">auto</a> ranges::find_end </td>
          <td>(</td>
          <td class="paramtype">Rng1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Rng2 &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R&#160;</td>
          <td class="paramname"><em>pred</em> = <code>R{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; safe_subrange_t&lt;Rng1&gt;   
                requires forward_range&lt;Rng1&gt; &amp;&amp; forward_range&lt;Rng2&gt; &amp;&amp;
                indirect_relation&lt;R, projected&lt;iterator_t&lt;Rng1&gt;, P&gt;, iterator_t&lt;Rng2&gt;&gt; 
        </td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="find__end_8hpp.html">range/v3/algorithm/find_end.hpp</a>&gt;</code></p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="ga12a7a0c47e8ee9b4a4448ff7de8d7a8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga12a7a0c47e8ee9b4a4448ff7de8d7a8b">&#9670;&nbsp;</a></span>find_first_of()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng0 , typename Rng1 , typename R  = equal_to, typename P0  = identity, typename P1  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classauto.html">auto</a> ranges::find_first_of </td>
          <td>(</td>
          <td class="paramtype">Rng0 &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Rng1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R&#160;</td>
          <td class="paramname"><em>pred</em> = <code>R{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P0&#160;</td>
          <td class="paramname"><em>proj0</em> = <code>P0{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P1&#160;</td>
          <td class="paramname"><em>proj1</em> = <code>P1{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; safe_iterator_t&lt;Rng0&gt;   
                requires input_range&lt;Rng0&gt; &amp;&amp; forward_range&lt;Rng1&gt; &amp;&amp;
                indirect_relation&lt;R,
                                  projected&lt;iterator_t&lt;Rng0&gt;, P0&gt;,
                                  projected&lt;iterator_t&lt;Rng1&gt;, P1&gt;&gt; 
        </td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="find__first__of_8hpp.html">range/v3/algorithm/find_first_of.hpp</a>&gt;</code></p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="ga97d40229d9524a2dca7bdfa1dc41eb7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga97d40229d9524a2dca7bdfa1dc41eb7f">&#9670;&nbsp;</a></span>find_if() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename S , typename F , typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classauto.html">auto</a> ranges::find_if </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; I   
                requires input_iterator&lt;I&gt; &amp;&amp; sentinel_for&lt;S, I&gt; &amp;&amp;
                indirect_unary_predicate&lt;F, projected&lt;I, P&gt;&gt; 
        </td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="find__if_8hpp.html">range/v3/algorithm/find_if.hpp</a>&gt;</code></p>

<p>template function <code>find</code> </p>
<p>range-based version of the <code>find</code> std algorithm</p>
<dl class="section pre"><dt>Precondition</dt><dd><code>Rng</code> is a model of the <code>range</code> concept </dd>
<dd>
<code>I</code> is a model of the <code>input_iterator</code> concept </dd>
<dd>
<code>S</code> is a model of the <code>sentinel_for&lt;I&gt;</code> concept </dd>
<dd>
<code>P</code> is a model of the <code>invocable&lt;V&gt;</code> concept, where <code>V</code> is the value type of I. </dd>
<dd>
<code>F</code> models <code>predicate&lt;X&gt;</code>, where <code>X</code> is the result type of <code>invocable&lt;P, V&gt;</code> </dd></dl>

</div>
</div>
<a id="ga83655c30e620ed517ebd2f6ea039f84b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga83655c30e620ed517ebd2f6ea039f84b">&#9670;&nbsp;</a></span>find_if() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng , typename F , typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classauto.html">auto</a> ranges::find_if </td>
          <td>(</td>
          <td class="paramtype">Rng &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; safe_iterator_t&lt;Rng&gt;   
                requires input_range&lt;Rng&gt; &amp;&amp;
                indirect_unary_predicate&lt;F, projected&lt;iterator_t&lt;Rng&gt;, P&gt;&gt; 
        </td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="find__if_8hpp.html">range/v3/algorithm/find_if.hpp</a>&gt;</code></p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="gad5baa6a43c9610670e8256e4ee4b9eb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad5baa6a43c9610670e8256e4ee4b9eb1">&#9670;&nbsp;</a></span>find_if_not() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename S , typename F , typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classauto.html">auto</a> ranges::find_if_not </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; I   
                requires input_iterator&lt;I&gt; &amp;&amp; sentinel_for&lt;S, I&gt; &amp;&amp;
                indirect_unary_predicate&lt;F, projected&lt;I, P&gt;&gt; 
        </td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="find__if__not_8hpp.html">range/v3/algorithm/find_if_not.hpp</a>&gt;</code></p>

<p>template function <code>find_if_not</code> </p>
<p>range-based version of the <code>find_if_not</code> std algorithm</p>
<dl class="section pre"><dt>Precondition</dt><dd><code>Rng</code> is a model of the <code>range</code> concept </dd>
<dd>
<code>I</code> is a model of the <code>input_iterator</code> concept </dd>
<dd>
<code>S</code> is a model of the <code>sentinel_for&lt;I&gt;</code> concept </dd>
<dd>
<code>P</code> is a model of the <code>invocable&lt;V&gt;</code> concept, where <code>V</code> is the value type of I. </dd>
<dd>
<code>F</code> models <code>predicate&lt;X&gt;</code>, where <code>X</code> is the result type of <code>invocable&lt;P, V&gt;</code> </dd></dl>

</div>
</div>
<a id="ga7017c275cc667040bcbd35f568571f11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7017c275cc667040bcbd35f568571f11">&#9670;&nbsp;</a></span>find_if_not() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng , typename F , typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classauto.html">auto</a> ranges::find_if_not </td>
          <td>(</td>
          <td class="paramtype">Rng &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; safe_iterator_t&lt;Rng&gt;   
                requires input_range&lt;Rng&gt; &amp;&amp;
                indirect_unary_predicate&lt;F, projected&lt;iterator_t&lt;Rng&gt;, P&gt;&gt; 
        </td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="find__if__not_8hpp.html">range/v3/algorithm/find_if_not.hpp</a>&gt;</code></p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="gaa213bfef81a971e1523c4510112de5e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa213bfef81a971e1523c4510112de5e4">&#9670;&nbsp;</a></span>for_each()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng , typename F , typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classauto.html">auto</a> ranges::for_each </td>
          <td>(</td>
          <td class="paramtype">Rng &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; for_each_result&lt;safe_iterator_t&lt;Rng&gt;, F&gt;   
                requires input_range&lt;Rng&gt; &amp;&amp;
                indirectly_unary_invocable&lt;F, projected&lt;iterator_t&lt;Rng&gt;, P&gt;&gt; 
        </td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="algorithm_2for__each_8hpp.html">range/v3/algorithm/for_each.hpp</a>&gt;</code></p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="gae8bf0c761837f2a0fb513a6bfee8db26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae8bf0c761837f2a0fb513a6bfee8db26">&#9670;&nbsp;</a></span>for_each_n()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng , typename F , typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classauto.html">auto</a> ranges::for_each_n </td>
          <td>(</td>
          <td class="paramtype">Rng &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">range_difference_t&lt; Rng &gt;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; safe_iterator_t&lt;Rng&gt;   
                requires input_range&lt;Rng&gt; &amp;&amp;
                indirectly_unary_invocable&lt;F, projected&lt;iterator_t&lt;Rng&gt;, P&gt;&gt; 
        </td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="for__each__n_8hpp.html">range/v3/algorithm/for_each_n.hpp</a>&gt;</code></p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="gae277dfff0628b1e0f057d81ad801db10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae277dfff0628b1e0f057d81ad801db10">&#9670;&nbsp;</a></span>generate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng , typename F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classauto.html">auto</a> ranges::generate </td>
          <td>(</td>
          <td class="paramtype">Rng &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>fun</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; generate_result&lt;safe_iterator_t&lt;Rng&gt;, F&gt;   
                requires invocable&lt;F &amp;&gt; &amp;&amp; output_range&lt;Rng, invoke_result_t&lt;F &amp;&gt;&gt; 
        </td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="algorithm_2generate_8hpp.html">range/v3/algorithm/generate.hpp</a>&gt;</code></p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="gad038da5f95761d60c391d925d81d7291"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad038da5f95761d60c391d925d81d7291">&#9670;&nbsp;</a></span>includes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng1 , typename Rng2 , typename C  = less, typename P1  = identity, typename P2  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classauto.html">auto</a> ranges::includes </td>
          <td>(</td>
          <td class="paramtype">Rng1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Rng2 &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em> = <code>C{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P1&#160;</td>
          <td class="paramname"><em>proj1</em> = <code>P1{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P2&#160;</td>
          <td class="paramname"><em>proj2</em> = <code>P2{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool   
                requires input_range&lt;Rng1&gt; &amp;&amp; input_range&lt;Rng2&gt; &amp;&amp;
                indirect_strict_weak_order&lt;C,
                                           projected&lt;iterator_t&lt;Rng1&gt;, P1&gt;,
                                           projected&lt;iterator_t&lt;Rng2&gt;, P2&gt;&gt; 
        </td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="algorithm_2set__algorithm_8hpp.html">range/v3/algorithm/set_algorithm.hpp</a>&gt;</code></p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="gafff3693db2a1593b6f7f6997466e5906"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafff3693db2a1593b6f7f6997466e5906">&#9670;&nbsp;</a></span>inplace_merge()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng , typename C  = less, typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classauto.html">auto</a> ranges::inplace_merge </td>
          <td>(</td>
          <td class="paramtype">Rng &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">iterator_t&lt; Rng &gt;&#160;</td>
          <td class="paramname"><em>middle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em> = <code>C{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; safe_iterator_t&lt;Rng&gt;   
                requires bidirectional_range&lt;Rng&gt; &amp;&amp; sortable&lt;iterator_t&lt;Rng&gt;, C, P&gt; 
        </td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="inplace__merge_8hpp.html">range/v3/algorithm/inplace_merge.hpp</a>&gt;</code></p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="ga650418789a5ddc477e26fad6fe7f0fb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga650418789a5ddc477e26fad6fe7f0fb2">&#9670;&nbsp;</a></span>is_heap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng , typename C  = less, typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classauto.html">auto</a> ranges::is_heap </td>
          <td>(</td>
          <td class="paramtype">Rng &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em> = <code>C{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool   
                requires random_access_range&lt;Rng&gt; &amp;&amp;
                indirect_strict_weak_order&lt;C, projected&lt;iterator_t&lt;Rng&gt;, P&gt;&gt; 
        </td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="heap__algorithm_8hpp.html">range/v3/algorithm/heap_algorithm.hpp</a>&gt;</code></p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="ga79c070bf7916a0903bf1e910f4b8bf7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga79c070bf7916a0903bf1e910f4b8bf7f">&#9670;&nbsp;</a></span>is_heap_until()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng , typename C  = less, typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classauto.html">auto</a> ranges::is_heap_until </td>
          <td>(</td>
          <td class="paramtype">Rng &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em> = <code>C{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; safe_iterator_t&lt;Rng&gt;   
                requires random_access_range&lt;Rng&gt; &amp;&amp;
                indirect_strict_weak_order&lt;C, projected&lt;iterator_t&lt;Rng&gt;, P&gt;&gt; 
        </td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="heap__algorithm_8hpp.html">range/v3/algorithm/heap_algorithm.hpp</a>&gt;</code></p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="gada630b75096ea1e1276173e0b6464ed6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gada630b75096ea1e1276173e0b6464ed6">&#9670;&nbsp;</a></span>is_partitioned()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng , typename C , typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classauto.html">auto</a> ranges::is_partitioned </td>
          <td>(</td>
          <td class="paramtype">Rng &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool   
                requires input_range&lt;Rng&gt; &amp;&amp;
                indirect_unary_predicate&lt;C, projected&lt;iterator_t&lt;Rng&gt;, P&gt;&gt; 
        </td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="is__partitioned_8hpp.html">range/v3/algorithm/is_partitioned.hpp</a>&gt;</code></p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="gaa6c38c42c15abc90162194dad95b216b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa6c38c42c15abc90162194dad95b216b">&#9670;&nbsp;</a></span>is_permutation() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I1 , typename S1 , typename I2 , typename S2 , typename C  = equal_to, typename P1  = identity, typename P2  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classauto.html">auto</a> ranges::is_permutation </td>
          <td>(</td>
          <td class="paramtype">I1&#160;</td>
          <td class="paramname"><em>begin1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S1&#160;</td>
          <td class="paramname"><em>end1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I2&#160;</td>
          <td class="paramname"><em>begin2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S2&#160;</td>
          <td class="paramname"><em>end2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em> = <code>C{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P1&#160;</td>
          <td class="paramname"><em>proj1</em> = <code>P1{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P2&#160;</td>
          <td class="paramname"><em>proj2</em> = <code>P2{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool   
                requires forward_iterator&lt;I1&gt; &amp;&amp; sentinel_for&lt;S1, I1&gt; &amp;&amp;
                forward_iterator&lt;I2&gt; &amp;&amp; sentinel_for&lt;S2, I2&gt; &amp;&amp;
                indirectly_comparable&lt;I1, I2, C, P1, P2&gt; 
        </td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="permutation_8hpp.html">range/v3/algorithm/permutation.hpp</a>&gt;</code></p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="gafba37d0b7f7fc51effa32f19baa56ad8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafba37d0b7f7fc51effa32f19baa56ad8">&#9670;&nbsp;</a></span>is_permutation() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng1 , typename I2Ref , typename C  = equal_to, typename P1  = identity, typename P2  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classauto.html">auto</a> ranges::is_permutation </td>
          <td>(</td>
          <td class="paramtype">Rng1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I2Ref &amp;&amp;&#160;</td>
          <td class="paramname"><em>begin2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em> = <code>C{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P1&#160;</td>
          <td class="paramname"><em>proj1</em> = <code>P1{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P2&#160;</td>
          <td class="paramname"><em>proj2</em> = <code>P2{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool   
                requires forward_range&lt;Rng1&gt; &amp;&amp; forward_iterator&lt;uncvref_t&lt;I2Ref&gt;&gt; &amp;&amp;
                indirectly_comparable&lt;iterator_t&lt;Rng1&gt;, uncvref_t&lt;I2Ref&gt;, C, P1, P2&gt; 
        </td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="permutation_8hpp.html">range/v3/algorithm/permutation.hpp</a>&gt;</code></p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="ga74f17609033a0f20f0bc6482d91a7aca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga74f17609033a0f20f0bc6482d91a7aca">&#9670;&nbsp;</a></span>is_permutation() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng1 , typename Rng2 , typename C  = equal_to, typename P1  = identity, typename P2  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classauto.html">auto</a> ranges::is_permutation </td>
          <td>(</td>
          <td class="paramtype">Rng1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Rng2 &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em> = <code>C{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P1&#160;</td>
          <td class="paramname"><em>proj1</em> = <code>P1{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P2&#160;</td>
          <td class="paramname"><em>proj2</em> = <code>P2{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool   
                requires forward_range&lt;Rng1&gt; &amp;&amp; forward_range&lt;Rng2&gt; &amp;&amp;
                indirectly_comparable&lt;iterator_t&lt;Rng1&gt;, iterator_t&lt;Rng2&gt;, C, P1, P2&gt; 
        </td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="permutation_8hpp.html">range/v3/algorithm/permutation.hpp</a>&gt;</code></p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="ga9ef0c9489d476d96092f8b4c77b3ccf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9ef0c9489d476d96092f8b4c77b3ccf4">&#9670;&nbsp;</a></span>is_sorted() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename S , typename R  = less, typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classauto.html">auto</a> ranges::is_sorted </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R&#160;</td>
          <td class="paramname"><em>rel</em> = <code>R{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool   
                requires forward_iterator&lt;I&gt; &amp;&amp; sentinel_for&lt;S, I&gt; &amp;&amp;
                indirect_strict_weak_order&lt;R, projected&lt;I, P&gt;&gt; 
        </td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="is__sorted_8hpp.html">range/v3/algorithm/is_sorted.hpp</a>&gt;</code></p>

<p>template function <code>is_sorted</code> </p>
<p>range-based version of the <code>is_sorted</code> std algorithm</p>
<p>Works on forward_ranges</p>
<dl class="section pre"><dt>Precondition</dt><dd><code>Rng</code> is a model of the <code>forward_range</code> concept </dd>
<dd>
<code>I</code> is a model of the <code>forward_iterator</code> concept </dd>
<dd>
<code>S</code> and <code>I</code> model the <code>sentinel_for&lt;S, I&gt;</code> concept </dd>
<dd>
<code>R</code> and <code>projected&lt;I, P&gt;</code> model the <code>indirect_strict_weak_order&lt;R, projected&lt;I, P&gt;&gt;</code> concept </dd></dl>

</div>
</div>
<a id="ga49836ea88cdda883cd29bc1172b2acc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga49836ea88cdda883cd29bc1172b2acc6">&#9670;&nbsp;</a></span>is_sorted() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng , typename R  = less, typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classauto.html">auto</a> ranges::is_sorted </td>
          <td>(</td>
          <td class="paramtype">Rng &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R&#160;</td>
          <td class="paramname"><em>rel</em> = <code>R{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool   
                requires forward_range&lt;Rng&gt; &amp;&amp;
                indirect_strict_weak_order&lt;R, projected&lt;iterator_t&lt;Rng&gt;, P&gt;&gt; 
        </td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="is__sorted_8hpp.html">range/v3/algorithm/is_sorted.hpp</a>&gt;</code></p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="gae1e0c8d007fae6db8abaa2f47a7cc0d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae1e0c8d007fae6db8abaa2f47a7cc0d9">&#9670;&nbsp;</a></span>is_sorted_until() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename S , typename R  = less, typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classauto.html">auto</a> ranges::is_sorted_until </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R&#160;</td>
          <td class="paramname"><em>pred</em> = <code>R{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; I   
                requires forward_iterator&lt;I&gt; &amp;&amp; sentinel_for&lt;S, I&gt; &amp;&amp;
                indirect_strict_weak_order&lt;R, projected&lt;I, P&gt;&gt; 
        </td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="is__sorted__until_8hpp.html">range/v3/algorithm/is_sorted_until.hpp</a>&gt;</code></p>

<p>template function <code>is_sorted_until</code> </p>
<p>range-based version of the <code>is_sorted_until</code> std algorithm</p>
<p>Works on forward_ranges</p>
<dl class="section pre"><dt>Precondition</dt><dd><code>Rng</code> is a model of the <code>forward_range</code> concept </dd>
<dd>
<code>I</code> is a model of the <code>forward_iterator</code> concept </dd>
<dd>
<code>S</code> and <code>I</code> model the <code>sentinel_for&lt;S, I&gt;</code> concept </dd>
<dd>
<code>R</code> and <code>projected&lt;I, P&gt;</code> model the <code>indirect_strict_weak_order&lt;R, projected&lt;I, P&gt;&gt;</code> concept </dd></dl>

</div>
</div>
<a id="gac588ad6fdec29edaf8695c066b5251f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac588ad6fdec29edaf8695c066b5251f8">&#9670;&nbsp;</a></span>is_sorted_until() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng , typename R  = less, typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classauto.html">auto</a> ranges::is_sorted_until </td>
          <td>(</td>
          <td class="paramtype">Rng &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R&#160;</td>
          <td class="paramname"><em>pred</em> = <code>R{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; safe_iterator_t&lt;Rng&gt;   
                requires forward_range&lt;Rng&gt; &amp;&amp;
                indirect_strict_weak_order&lt;R, projected&lt;iterator_t&lt;Rng&gt;, P&gt;&gt; 
        </td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="is__sorted__until_8hpp.html">range/v3/algorithm/is_sorted_until.hpp</a>&gt;</code></p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="ga1fca7df6df82e9ff76107a5cd96a9070"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1fca7df6df82e9ff76107a5cd96a9070">&#9670;&nbsp;</a></span>lexicographical_compare()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng0 , typename Rng1 , typename C  = less, typename P0  = identity, typename P1  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classauto.html">auto</a> ranges::lexicographical_compare </td>
          <td>(</td>
          <td class="paramtype">Rng0 &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Rng1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em> = <code>C{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P0&#160;</td>
          <td class="paramname"><em>proj0</em> = <code>P0{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P1&#160;</td>
          <td class="paramname"><em>proj1</em> = <code>P1{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool   
                requires input_range&lt;Rng0&gt; &amp;&amp; input_range&lt;Rng1&gt; &amp;&amp;
                indirect_strict_weak_order&lt;C,
                                           projected&lt;iterator_t&lt;Rng0&gt;, P0&gt;,
                                           projected&lt;iterator_t&lt;Rng1&gt;, P1&gt;&gt; 
        </td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="lexicographical__compare_8hpp.html">range/v3/algorithm/lexicographical_compare.hpp</a>&gt;</code></p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="gabd90b524d80aa309189dd81df16cd3a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabd90b524d80aa309189dd81df16cd3a5">&#9670;&nbsp;</a></span>lower_bound()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng , typename V , typename C  = less, typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classauto.html">auto</a> ranges::lower_bound </td>
          <td>(</td>
          <td class="paramtype">Rng &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">V const &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em> = <code>C{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; safe_iterator_t&lt;Rng&gt;   
                requires forward_range&lt;Rng&gt; &amp;&amp;
                indirect_strict_weak_order&lt;C, V const *, projected&lt;iterator_t&lt;Rng&gt;, P&gt;&gt; 
        </td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="lower__bound_8hpp.html">range/v3/algorithm/lower_bound.hpp</a>&gt;</code></p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="gaf24f51e58d9b234b4687a878d65050cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf24f51e58d9b234b4687a878d65050cd">&#9670;&nbsp;</a></span>make_heap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng , typename C  = less, typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classauto.html">auto</a> ranges::make_heap </td>
          <td>(</td>
          <td class="paramtype">Rng &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em> = <code>C{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; safe_iterator_t&lt;Rng&gt;   
                requires random_access_range&lt;Rng&gt; &amp;&amp; sortable&lt;iterator_t&lt;Rng&gt;, C, P&gt; 
        </td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="heap__algorithm_8hpp.html">range/v3/algorithm/heap_algorithm.hpp</a>&gt;</code></p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="ga1d4e1bb60d9bfb5e5437974eed0b03c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1d4e1bb60d9bfb5e5437974eed0b03c4">&#9670;&nbsp;</a></span>max() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng , typename C  = less, typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classauto.html">auto</a> ranges::max </td>
          <td>(</td>
          <td class="paramtype">Rng &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em> = <code>C{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; range_value_t&lt;Rng&gt;   
                requires input_range&lt;Rng&gt; &amp;&amp;
                indirect_strict_weak_order&lt;C, projected&lt;iterator_t&lt;Rng&gt;, P&gt;&gt; &amp;&amp;
                indirectly_copyable_storable&lt;iterator_t&lt;Rng&gt;, range_value_t&lt;Rng&gt; *&gt; 
        </td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="max_8hpp.html">range/v3/algorithm/max.hpp</a>&gt;</code></p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="gaedb6df45bc43e4cee4be367f76786b99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaedb6df45bc43e4cee4be367f76786b99">&#9670;&nbsp;</a></span>max() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename C  = less, typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classauto.html">auto</a> ranges::max </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; T &gt; const &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em> = <code>C{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; T   
                requires copyable&lt;T&gt; &amp;&amp;
                indirect_strict_weak_order&lt;C, projected&lt;T const *, P&gt;&gt; 
        </td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="max_8hpp.html">range/v3/algorithm/max.hpp</a>&gt;</code></p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="ga4e5950e393a0aee33b00b34c2f8e97c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4e5950e393a0aee33b00b34c2f8e97c9">&#9670;&nbsp;</a></span>max_element()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng , typename C  = less, typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classauto.html">auto</a> ranges::max_element </td>
          <td>(</td>
          <td class="paramtype">Rng &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em> = <code>C{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; safe_iterator_t&lt;Rng&gt;   
                requires forward_range&lt;Rng&gt; &amp;&amp;
                indirect_strict_weak_order&lt;C, projected&lt;iterator_t&lt;Rng&gt;, P&gt;&gt; 
        </td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="max__element_8hpp.html">range/v3/algorithm/max_element.hpp</a>&gt;</code></p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="ga9dc32f54d90650bb5e2604f37374bea2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9dc32f54d90650bb5e2604f37374bea2">&#9670;&nbsp;</a></span>merge()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng0 , typename Rng1 , typename O , typename C  = less, typename P0  = identity, typename P1  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classauto.html">auto</a> ranges::merge </td>
          <td>(</td>
          <td class="paramtype">Rng0 &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Rng1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">O&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em> = <code>C{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P0&#160;</td>
          <td class="paramname"><em>proj0</em> = <code>P0{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P1&#160;</td>
          <td class="paramname"><em>proj1</em> = <code>P1{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; merge_result&lt;safe_iterator_t&lt;Rng0&gt;, safe_iterator_t&lt;Rng1&gt;, O&gt;   
                requires range&lt;Rng0&gt; &amp;&amp; range&lt;Rng1&gt; &amp;&amp;
                mergeable&lt;iterator_t&lt;Rng0&gt;, iterator_t&lt;Rng1&gt;, O, C, P0, P1&gt; 
        </td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="merge_8hpp.html">range/v3/algorithm/merge.hpp</a>&gt;</code></p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="gaee8206c71bf8a3141ffd74d2fa86b9ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaee8206c71bf8a3141ffd74d2fa86b9ee">&#9670;&nbsp;</a></span>min() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng , typename C  = less, typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classauto.html">auto</a> ranges::min </td>
          <td>(</td>
          <td class="paramtype">Rng &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em> = <code>C{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; range_value_t&lt;Rng&gt;   
                requires input_range&lt;Rng&gt; &amp;&amp;
                indirect_strict_weak_order&lt;C, projected&lt;iterator_t&lt;Rng&gt;, P&gt;&gt; &amp;&amp;
                indirectly_copyable_storable&lt;iterator_t&lt;Rng&gt;, range_value_t&lt;Rng&gt; *&gt; 
        </td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="min_8hpp.html">range/v3/algorithm/min.hpp</a>&gt;</code></p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="ga483adbc4117b6a40342fffe1d0472c1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga483adbc4117b6a40342fffe1d0472c1a">&#9670;&nbsp;</a></span>min() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename C  = less, typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classauto.html">auto</a> ranges::min </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; T &gt; const &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em> = <code>C{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; T   
                requires copyable&lt;T&gt; &amp;&amp;
                indirect_strict_weak_order&lt;C, projected&lt;T const *, P&gt;&gt; 
        </td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="min_8hpp.html">range/v3/algorithm/min.hpp</a>&gt;</code></p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="gaa486ad46a5307c11a3d1be2f6683cf1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa486ad46a5307c11a3d1be2f6683cf1c">&#9670;&nbsp;</a></span>min_element()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng , typename C  = less, typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classauto.html">auto</a> ranges::min_element </td>
          <td>(</td>
          <td class="paramtype">Rng &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em> = <code>C{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; safe_iterator_t&lt;Rng&gt;   
                requires forward_range&lt;Rng&gt; &amp;&amp;
                indirect_strict_weak_order&lt;C, projected&lt;iterator_t&lt;Rng&gt;, P&gt;&gt; 
        </td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="min__element_8hpp.html">range/v3/algorithm/min_element.hpp</a>&gt;</code></p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="ga93f42f45f3ba905e1eb1cd573f172a4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga93f42f45f3ba905e1eb1cd573f172a4b">&#9670;&nbsp;</a></span>minmax() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng , typename C  = less, typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classauto.html">auto</a> ranges::minmax </td>
          <td>(</td>
          <td class="paramtype">Rng &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em> = <code>C{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; minmax_result&lt;range_value_t&lt;Rng&gt;&gt;   
                requires input_range&lt;Rng&gt; &amp;&amp;
                indirect_strict_weak_order&lt;C, projected&lt;iterator_t&lt;Rng&gt;, P&gt;&gt; &amp;&amp;
                indirectly_copyable_storable&lt;iterator_t&lt;Rng&gt;, range_value_t&lt;Rng&gt; *&gt; 
        </td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="minmax_8hpp.html">range/v3/algorithm/minmax.hpp</a>&gt;</code></p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="ga7f84b92881ac8d36ec500601758b489e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7f84b92881ac8d36ec500601758b489e">&#9670;&nbsp;</a></span>minmax() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename C  = less, typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classauto.html">auto</a> ranges::minmax </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; T &gt; const &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em> = <code>C{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; minmax_result&lt;T&gt;   
                requires copyable&lt;T&gt; &amp;&amp;
                indirect_strict_weak_order&lt;C, projected&lt;T const *, P&gt;&gt; 
        </td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="minmax_8hpp.html">range/v3/algorithm/minmax.hpp</a>&gt;</code></p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="gae13f61b4b199b34e72551c035de4a491"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae13f61b4b199b34e72551c035de4a491">&#9670;&nbsp;</a></span>minmax_element()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng , typename C  = less, typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classauto.html">auto</a> ranges::minmax_element </td>
          <td>(</td>
          <td class="paramtype">Rng &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em> = <code>C{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; minmax_element_result&lt;safe_iterator_t&lt;Rng&gt;&gt;   
                requires forward_range&lt;Rng&gt; &amp;&amp;
                indirect_strict_weak_order&lt;C, projected&lt;iterator_t&lt;Rng&gt;, P&gt;&gt; 
        </td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="minmax__element_8hpp.html">range/v3/algorithm/minmax_element.hpp</a>&gt;</code></p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="ga4da42176e10f531b5b742c55dd5647d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4da42176e10f531b5b742c55dd5647d0">&#9670;&nbsp;</a></span>mismatch() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I1 , typename S1 , typename I2 , typename S2 , typename C  = equal_to, typename P1  = identity, typename P2  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classauto.html">auto</a> ranges::mismatch </td>
          <td>(</td>
          <td class="paramtype">I1&#160;</td>
          <td class="paramname"><em>begin1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S1&#160;</td>
          <td class="paramname"><em>end1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I2&#160;</td>
          <td class="paramname"><em>begin2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S2&#160;</td>
          <td class="paramname"><em>end2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em> = <code>C{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P1&#160;</td>
          <td class="paramname"><em>proj1</em> = <code>P1{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P2&#160;</td>
          <td class="paramname"><em>proj2</em> = <code>P2{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; mismatch_result&lt;I1, I2&gt;   
                requires input_iterator&lt;I1&gt; &amp;&amp; sentinel_for&lt;S1, I1&gt; &amp;&amp;
                input_iterator&lt;I2&gt; &amp;&amp; sentinel_for&lt;S2, I2&gt; &amp;&amp;
                indirect_relation&lt;C, projected&lt;I1, P1&gt;, projected&lt;I2, P2&gt;&gt; 
        </td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="mismatch_8hpp.html">range/v3/algorithm/mismatch.hpp</a>&gt;</code></p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="gafdbcd0a2e221a907444f025e93bac41f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafdbcd0a2e221a907444f025e93bac41f">&#9670;&nbsp;</a></span>mismatch() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng1 , typename I2Ref , typename C  = equal_to, typename P1  = identity, typename P2  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classauto.html">auto</a> ranges::mismatch </td>
          <td>(</td>
          <td class="paramtype">Rng1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I2Ref &amp;&amp;&#160;</td>
          <td class="paramname"><em>begin2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em> = <code>C{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P1&#160;</td>
          <td class="paramname"><em>proj1</em> = <code>P1{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P2&#160;</td>
          <td class="paramname"><em>proj2</em> = <code>P2{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; mismatch_result&lt;safe_iterator_t&lt;Rng1&gt;, uncvref_t&lt;I2Ref&gt;&gt;   
                requires input_range&lt;Rng1&gt; &amp;&amp; input_iterator&lt;uncvref_t&lt;I2Ref&gt;&gt; &amp;&amp;
                indirect_relation&lt;C,
                                  projected&lt;iterator_t&lt;Rng1&gt;, P1&gt;,
                                  projected&lt;uncvref_t&lt;I2Ref&gt;, P2&gt;&gt; 
        </td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="mismatch_8hpp.html">range/v3/algorithm/mismatch.hpp</a>&gt;</code></p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="gae9b4343602798cdf8687652d39af9486"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae9b4343602798cdf8687652d39af9486">&#9670;&nbsp;</a></span>mismatch() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng1 , typename Rng2 , typename C  = equal_to, typename P1  = identity, typename P2  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classauto.html">auto</a> ranges::mismatch </td>
          <td>(</td>
          <td class="paramtype">Rng1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Rng2 &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em> = <code>C{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P1&#160;</td>
          <td class="paramname"><em>proj1</em> = <code>P1{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P2&#160;</td>
          <td class="paramname"><em>proj2</em> = <code>P2{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; mismatch_result&lt;safe_iterator_t&lt;Rng1&gt;, safe_iterator_t&lt;Rng2&gt;&gt;   
                requires input_range&lt;Rng1&gt; &amp;&amp; input_range&lt;Rng2&gt; &amp;&amp;
                indirect_relation&lt;C,
                                  projected&lt;iterator_t&lt;Rng1&gt;, P1&gt;,
                                  projected&lt;iterator_t&lt;Rng2&gt;, P2&gt;&gt; 
        </td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="mismatch_8hpp.html">range/v3/algorithm/mismatch.hpp</a>&gt;</code></p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="gaa55485146994b298d1392f1aa421fdfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa55485146994b298d1392f1aa421fdfe">&#9670;&nbsp;</a></span>move()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng , typename O &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classauto.html">auto</a> ranges::move </td>
          <td>(</td>
          <td class="paramtype">Rng &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">O&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; move_result&lt;safe_iterator_t&lt;Rng&gt;, O&gt;   
                requires input_range&lt;Rng&gt; &amp;&amp; weakly_incrementable&lt;O&gt; &amp;&amp;
                indirectly_movable&lt;iterator_t&lt;Rng&gt;, O&gt; 
        </td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="algorithm_2move_8hpp.html">range/v3/algorithm/move.hpp</a>&gt;</code></p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

<p class="reference">Referenced by <a class="el" href="group__group-utility.html#gaed1565c38a1b2177036d4493be2e65b8">ranges::aux::move_fn::operator|()</a>.</p>

</div>
</div>
<a id="ga1bcb9fe56632812478c526a887f97e95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1bcb9fe56632812478c526a887f97e95">&#9670;&nbsp;</a></span>move_backward()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng , typename O &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classauto.html">auto</a> ranges::move_backward </td>
          <td>(</td>
          <td class="paramtype">Rng &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">O&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; move_backward_result&lt;safe_iterator_t&lt;Rng&gt;, O&gt;   
                requires bidirectional_range&lt;Rng&gt; &amp;&amp; bidirectional_iterator&lt;O&gt; &amp;&amp;
                indirectly_movable&lt;iterator_t&lt;Rng&gt;, O&gt; 
        </td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="move__backward_8hpp.html">range/v3/algorithm/move_backward.hpp</a>&gt;</code></p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="gac1d3b1235061a7fe7e207b40ed5cfe6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac1d3b1235061a7fe7e207b40ed5cfe6a">&#9670;&nbsp;</a></span>next_permutation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng , typename C  = less, typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classauto.html">auto</a> ranges::next_permutation </td>
          <td>(</td>
          <td class="paramtype">Rng &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em> = <code>C{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool   
                requires bidirectional_range&lt;Rng&gt; &amp;&amp; sortable&lt;iterator_t&lt;Rng&gt;, C, P&gt; 
        </td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="permutation_8hpp.html">range/v3/algorithm/permutation.hpp</a>&gt;</code></p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="ga7d61f3bfd6407213b28b03fba22596bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7d61f3bfd6407213b28b03fba22596bc">&#9670;&nbsp;</a></span>none_of()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng , typename F , typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classauto.html">auto</a> ranges::none_of </td>
          <td>(</td>
          <td class="paramtype">Rng &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool   
                requires input_range&lt;Rng&gt; &amp;&amp;
                indirect_unary_predicate&lt;F, projected&lt;iterator_t&lt;Rng&gt;, P&gt;&gt; 
        </td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="none__of_8hpp.html">range/v3/algorithm/none_of.hpp</a>&gt;</code></p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="gaa5b147dfccbce1396a9b0442b20fd066"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa5b147dfccbce1396a9b0442b20fd066">&#9670;&nbsp;</a></span>nth_element()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng , typename C  = less, typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classauto.html">auto</a> ranges::nth_element </td>
          <td>(</td>
          <td class="paramtype">Rng &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">iterator_t&lt; Rng &gt;&#160;</td>
          <td class="paramname"><em>nth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em> = <code>C{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; safe_iterator_t&lt;Rng&gt;   
                requires random_access_range&lt;Rng&gt; &amp;&amp; sortable&lt;iterator_t&lt;Rng&gt;, C, P&gt; 
        </td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="nth__element_8hpp.html">range/v3/algorithm/nth_element.hpp</a>&gt;</code></p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="gafbd4c9c1cbca2961915d60ab126c5599"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafbd4c9c1cbca2961915d60ab126c5599">&#9670;&nbsp;</a></span>partial_sort()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng , typename C  = less, typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classauto.html">auto</a> ranges::partial_sort </td>
          <td>(</td>
          <td class="paramtype">Rng &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">iterator_t&lt; Rng &gt;&#160;</td>
          <td class="paramname"><em>middle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em> = <code>C{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; safe_iterator_t&lt;Rng&gt;   
                requires sortable&lt;iterator_t&lt;Rng&gt;, C, P&gt; &amp;&amp; random_access_range&lt;Rng&gt; 
        </td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="partial__sort_8hpp.html">range/v3/algorithm/partial_sort.hpp</a>&gt;</code></p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="ga85ad09432b8357decede032bc1132cc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga85ad09432b8357decede032bc1132cc4">&#9670;&nbsp;</a></span>partial_sort_copy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InRng , typename OutRng , typename C  = less, typename PI  = identity, typename PO  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classauto.html">auto</a> ranges::partial_sort_copy </td>
          <td>(</td>
          <td class="paramtype">InRng &amp;&amp;&#160;</td>
          <td class="paramname"><em>in_rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutRng &amp;&amp;&#160;</td>
          <td class="paramname"><em>out_rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em> = <code>C{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PI&#160;</td>
          <td class="paramname"><em>in_proj</em> = <code>PI{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PO&#160;</td>
          <td class="paramname"><em>out_proj</em> = <code>PO{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; safe_iterator_t&lt;OutRng&gt;   
                requires input_range&lt;InRng&gt; &amp;&amp; random_access_range&lt;OutRng&gt; &amp;&amp;
                indirectly_copyable&lt;iterator_t&lt;InRng&gt;, iterator_t&lt;OutRng&gt;&gt; &amp;&amp;
                sortable&lt;iterator_t&lt;OutRng&gt;, C, PO&gt; &amp;&amp;
                indirect_strict_weak_order&lt;C,
                                           projected&lt;iterator_t&lt;InRng&gt;, PI&gt;,
                                           projected&lt;iterator_t&lt;OutRng&gt;, PO&gt;&gt; 
        </td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="partial__sort__copy_8hpp.html">range/v3/algorithm/partial_sort_copy.hpp</a>&gt;</code></p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="gabe6a0c55a56570b91f62b59f9dc906c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabe6a0c55a56570b91f62b59f9dc906c7">&#9670;&nbsp;</a></span>partition()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng , typename C , typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classauto.html">auto</a> ranges::partition </td>
          <td>(</td>
          <td class="paramtype">Rng &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; safe_iterator_t&lt;Rng&gt;   
                requires forward_range&lt;Rng&gt; &amp;&amp; permutable&lt;iterator_t&lt;Rng&gt;&gt; &amp;&amp;
                indirect_unary_predicate&lt;C, projected&lt;iterator_t&lt;Rng&gt;, P&gt;&gt; 
        </td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="partition_8hpp.html">range/v3/algorithm/partition.hpp</a>&gt;</code></p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="ga4ab1056bfb465fe2475dee970b81c9b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4ab1056bfb465fe2475dee970b81c9b5">&#9670;&nbsp;</a></span>partition_copy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng , typename O0 , typename O1 , typename C , typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classauto.html">auto</a> ranges::partition_copy </td>
          <td>(</td>
          <td class="paramtype">Rng &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">O0&#160;</td>
          <td class="paramname"><em>o0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">O1&#160;</td>
          <td class="paramname"><em>o1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; partition_copy_result&lt;safe_iterator_t&lt;Rng&gt;, O0, O1&gt;   
                requires input_range&lt;Rng&gt; &amp;&amp; weakly_incrementable&lt;O0&gt; &amp;&amp;
                weakly_incrementable&lt;O1&gt; &amp;&amp; indirectly_copyable&lt;iterator_t&lt;Rng&gt;, O0&gt; &amp;&amp;
                indirectly_copyable&lt;iterator_t&lt;Rng&gt;, O1&gt; &amp;&amp;
                indirect_unary_predicate&lt;C, projected&lt;iterator_t&lt;Rng&gt;, P&gt;&gt; 
        </td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="partition__copy_8hpp.html">range/v3/algorithm/partition_copy.hpp</a>&gt;</code></p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="gaee84a023a3794c8c42b117029542489e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaee84a023a3794c8c42b117029542489e">&#9670;&nbsp;</a></span>partition_point()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng , typename C , typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classauto.html">auto</a> ranges::partition_point </td>
          <td>(</td>
          <td class="paramtype">Rng &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; safe_iterator_t&lt;Rng&gt;   
                requires forward_range&lt;Rng&gt; &amp;&amp;
                indirect_unary_predicate&lt;C, projected&lt;iterator_t&lt;Rng&gt;, P&gt;&gt; 
        </td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="partition__point_8hpp.html">range/v3/algorithm/partition_point.hpp</a>&gt;</code></p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="ga9ca283ec71107d67f4f0785ca8e51bb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9ca283ec71107d67f4f0785ca8e51bb6">&#9670;&nbsp;</a></span>pop_heap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng , typename C  = less, typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classauto.html">auto</a> ranges::pop_heap </td>
          <td>(</td>
          <td class="paramtype">Rng &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em> = <code>C{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; safe_iterator_t&lt;Rng&gt;   
                requires random_access_range&lt;Rng&gt; &amp;&amp; sortable&lt;iterator_t&lt;Rng&gt;, C, P&gt; 
        </td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="heap__algorithm_8hpp.html">range/v3/algorithm/heap_algorithm.hpp</a>&gt;</code></p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="ga98298bd4c8bb759413d3f668a4eeaa99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga98298bd4c8bb759413d3f668a4eeaa99">&#9670;&nbsp;</a></span>prev_permutation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng , typename C  = less, typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classauto.html">auto</a> ranges::prev_permutation </td>
          <td>(</td>
          <td class="paramtype">Rng &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em> = <code>C{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool   
                requires bidirectional_range&lt;Rng&gt; &amp;&amp; sortable&lt;iterator_t&lt;Rng&gt;, C, P&gt; 
        </td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="permutation_8hpp.html">range/v3/algorithm/permutation.hpp</a>&gt;</code></p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="ga9dd789449e2d06c65de275f53a9b0e19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9dd789449e2d06c65de275f53a9b0e19">&#9670;&nbsp;</a></span>push_heap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng , typename C  = less, typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classauto.html">auto</a> ranges::push_heap </td>
          <td>(</td>
          <td class="paramtype">Rng &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em> = <code>C{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; safe_iterator_t&lt;Rng&gt;   
                requires random_access_range&lt;Rng&gt; &amp;&amp; sortable&lt;iterator_t&lt;Rng&gt;, C, P&gt; 
        </td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="heap__algorithm_8hpp.html">range/v3/algorithm/heap_algorithm.hpp</a>&gt;</code></p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="ga435ac9770234270704cb373f61410d84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga435ac9770234270704cb373f61410d84">&#9670;&nbsp;</a></span>remove()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng , typename T , typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classauto.html">auto</a> ranges::remove </td>
          <td>(</td>
          <td class="paramtype">Rng &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; safe_iterator_t&lt;Rng&gt;   
                requires forward_range&lt;Rng&gt; &amp;&amp; permutable&lt;iterator_t&lt;Rng&gt;&gt; &amp;&amp;
                indirect_relation&lt;<a class="el" href="structranges_1_1equal__to.html">equal_to</a>, projected&lt;iterator_t&lt;Rng&gt;, P&gt;, T const *&gt; 
        </td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="algorithm_2remove_8hpp.html">range/v3/algorithm/remove.hpp</a>&gt;</code></p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="gae1185b7f603d2a4781464b73a01e5dfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae1185b7f603d2a4781464b73a01e5dfa">&#9670;&nbsp;</a></span>remove_copy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng , typename O , typename T , typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classauto.html">auto</a> ranges::remove_copy </td>
          <td>(</td>
          <td class="paramtype">Rng &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">O&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; remove_copy_result&lt;safe_iterator_t&lt;Rng&gt;, O&gt;   
                requires input_range&lt;Rng&gt; &amp;&amp; weakly_incrementable&lt;O&gt; &amp;&amp;
                indirect_relation&lt;<a class="el" href="structranges_1_1equal__to.html">equal_to</a>, projected&lt;iterator_t&lt;Rng&gt;, P&gt;, T const *&gt; &amp;&amp;
                indirectly_copyable&lt;iterator_t&lt;Rng&gt;, O&gt; 
        </td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="remove__copy_8hpp.html">range/v3/algorithm/remove_copy.hpp</a>&gt;</code></p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="ga364855bec8817568b6acb4fa23ec653d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga364855bec8817568b6acb4fa23ec653d">&#9670;&nbsp;</a></span>remove_copy_if()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng , typename O , typename C , typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classauto.html">auto</a> ranges::remove_copy_if </td>
          <td>(</td>
          <td class="paramtype">Rng &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">O&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; remove_copy_if_result&lt;safe_iterator_t&lt;Rng&gt;, O&gt;   
                requires input_range&lt;Rng&gt; &amp;&amp; weakly_incrementable&lt;O&gt; &amp;&amp;
                indirect_unary_predicate&lt;C, projected&lt;iterator_t&lt;Rng&gt;, P&gt;&gt; &amp;&amp;
                indirectly_copyable&lt;iterator_t&lt;Rng&gt;, O&gt; 
        </td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="remove__copy__if_8hpp.html">range/v3/algorithm/remove_copy_if.hpp</a>&gt;</code></p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="ga6a9a8184903ae3931dfd31d1e2010242"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6a9a8184903ae3931dfd31d1e2010242">&#9670;&nbsp;</a></span>remove_if()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng , typename C , typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classauto.html">auto</a> ranges::remove_if </td>
          <td>(</td>
          <td class="paramtype">Rng &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; safe_iterator_t&lt;Rng&gt;   
                requires forward_range&lt;Rng&gt; &amp;&amp; permutable&lt;iterator_t&lt;Rng&gt;&gt; &amp;&amp;
                indirect_unary_predicate&lt;C, projected&lt;iterator_t&lt;Rng&gt;, P&gt;&gt; 
        </td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="algorithm_2remove__if_8hpp.html">range/v3/algorithm/remove_if.hpp</a>&gt;</code></p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="gad7acb64bbafb73fecf3cb8e598d80c3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad7acb64bbafb73fecf3cb8e598d80c3e">&#9670;&nbsp;</a></span>replace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng , typename T1 , typename T2 , typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classauto.html">auto</a> ranges::replace </td>
          <td>(</td>
          <td class="paramtype">Rng &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T1 const &amp;&#160;</td>
          <td class="paramname"><em>old_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2 const &amp;&#160;</td>
          <td class="paramname"><em>new_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; safe_iterator_t&lt;Rng&gt;   
                requires input_range&lt;Rng&gt; &amp;&amp; writable&lt;iterator_t&lt;Rng&gt;, T2 const &amp;&gt; &amp;&amp;
                indirect_relation&lt;<a class="el" href="structranges_1_1equal__to.html">equal_to</a>, projected&lt;iterator_t&lt;Rng&gt;, P&gt;, T1 const *&gt; 
        </td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="algorithm_2replace_8hpp.html">range/v3/algorithm/replace.hpp</a>&gt;</code></p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="gaa5f7293875320edb639082858cc6dcd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa5f7293875320edb639082858cc6dcd3">&#9670;&nbsp;</a></span>replace_copy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng , typename O , typename T1 , typename T2 , typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classauto.html">auto</a> ranges::replace_copy </td>
          <td>(</td>
          <td class="paramtype">Rng &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">O&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T1 const &amp;&#160;</td>
          <td class="paramname"><em>old_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2 const &amp;&#160;</td>
          <td class="paramname"><em>new_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; replace_copy_result&lt;safe_iterator_t&lt;Rng&gt;, O&gt;   
                requires input_range&lt;Rng&gt; &amp;&amp; output_iterator&lt;O, T2 const &amp;&gt; &amp;&amp;
                indirectly_copyable&lt;iterator_t&lt;Rng&gt;, O&gt; &amp;&amp;
                indirect_relation&lt;<a class="el" href="structranges_1_1equal__to.html">equal_to</a>, projected&lt;iterator_t&lt;Rng&gt;, P&gt;, T1 const *&gt; 
        </td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="replace__copy_8hpp.html">range/v3/algorithm/replace_copy.hpp</a>&gt;</code></p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="gaa27a8faf224a76ed63fd5cf5cdd7b529"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa27a8faf224a76ed63fd5cf5cdd7b529">&#9670;&nbsp;</a></span>replace_copy_if()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng , typename O , typename C , typename T , typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classauto.html">auto</a> ranges::replace_copy_if </td>
          <td>(</td>
          <td class="paramtype">Rng &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">O&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>new_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; replace_copy_if_result&lt;safe_iterator_t&lt;Rng&gt;, O&gt;   
                requires input_range&lt;Rng&gt; &amp;&amp; output_iterator&lt;O, T const &amp;&gt; &amp;&amp;
                indirect_unary_predicate&lt;C, projected&lt;iterator_t&lt;Rng&gt;, P&gt;&gt; &amp;&amp;
                indirectly_copyable&lt;iterator_t&lt;Rng&gt;, O&gt; 
        </td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="replace__copy__if_8hpp.html">range/v3/algorithm/replace_copy_if.hpp</a>&gt;</code></p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="ga2e329647d31be5cae926743c52380549"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2e329647d31be5cae926743c52380549">&#9670;&nbsp;</a></span>replace_if()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng , typename C , typename T , typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classauto.html">auto</a> ranges::replace_if </td>
          <td>(</td>
          <td class="paramtype">Rng &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>new_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; safe_iterator_t&lt;Rng&gt;   
                requires input_range&lt;Rng&gt; &amp;&amp;
                indirect_unary_predicate&lt;C, projected&lt;iterator_t&lt;Rng&gt;, P&gt;&gt; &amp;&amp;
                writable&lt;iterator_t&lt;Rng&gt;, T const &amp;&gt; 
        </td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="algorithm_2replace__if_8hpp.html">range/v3/algorithm/replace_if.hpp</a>&gt;</code></p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="ga351313cbb0a065290520980cbc66a629"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga351313cbb0a065290520980cbc66a629">&#9670;&nbsp;</a></span>reverse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng , typename I  = iterator_t&lt;Rng&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classauto.html">auto</a> ranges::reverse </td>
          <td>(</td>
          <td class="paramtype">Rng &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng</em></td><td>)</td>
          <td> -&gt; safe_iterator_t&lt;Rng&gt;   
                requires bidirectional_range&lt;Rng&gt; &amp;&amp; permutable&lt;I&gt; 
        </td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="algorithm_2reverse_8hpp.html">range/v3/algorithm/reverse.hpp</a>&gt;</code></p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="ga483df5fd74ee979c205476aa7f3c0959"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga483df5fd74ee979c205476aa7f3c0959">&#9670;&nbsp;</a></span>reverse_copy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng , typename O &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classauto.html">auto</a> ranges::reverse_copy </td>
          <td>(</td>
          <td class="paramtype">Rng &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">O&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; reverse_copy_result&lt;safe_iterator_t&lt;Rng&gt;, O&gt;   
                requires bidirectional_range&lt;Rng&gt; &amp;&amp; weakly_incrementable&lt;O&gt; &amp;&amp;
                indirectly_copyable&lt;iterator_t&lt;Rng&gt;, O&gt; 
        </td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="reverse__copy_8hpp.html">range/v3/algorithm/reverse_copy.hpp</a>&gt;</code></p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="ga0c51098540de4beed710f73f4f2836d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0c51098540de4beed710f73f4f2836d8">&#9670;&nbsp;</a></span>rotate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng , typename I  = iterator_t&lt;Rng&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classauto.html">auto</a> ranges::rotate </td>
          <td>(</td>
          <td class="paramtype">Rng &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>middle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; safe_subrange_t&lt;Rng&gt;   
                requires range&lt;Rng&gt; &amp;&amp; permutable&lt;I&gt; 
        </td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="rotate_8hpp.html">range/v3/algorithm/rotate.hpp</a>&gt;</code></p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="ga21b4b5a3e7ce0553270a6bb5e1b86dbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga21b4b5a3e7ce0553270a6bb5e1b86dbd">&#9670;&nbsp;</a></span>rotate_copy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng , typename O , typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classauto.html">auto</a> ranges::rotate_copy </td>
          <td>(</td>
          <td class="paramtype">Rng &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">iterator_t&lt; Rng &gt;&#160;</td>
          <td class="paramname"><em>middle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">O&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; rotate_copy_result&lt;safe_iterator_t&lt;Rng&gt;, O&gt;   
                requires range&lt;Rng&gt; &amp;&amp; weakly_incrementable&lt;O&gt; &amp;&amp;
                indirectly_copyable&lt;iterator_t&lt;Rng&gt;, O&gt; 
        </td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="rotate__copy_8hpp.html">range/v3/algorithm/rotate_copy.hpp</a>&gt;</code></p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="ga192ae87a73afdb587d4d4f58066ce0b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga192ae87a73afdb587d4d4f58066ce0b3">&#9670;&nbsp;</a></span>sample() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename S , typename ORng , typename Gen  = detail::default_random_engine &amp;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classauto.html">auto</a> ranges::sample </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ORng &amp;&amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Gen &amp;&amp;&#160;</td>
          <td class="paramname"><em>gen</em> = <code>detail::get_random_engine()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; sample_result&lt;I, safe_iterator_t&lt;ORng&gt;&gt;   
                requires input_iterator&lt;I&gt; &amp;&amp; sentinel_for&lt;S, I&gt; &amp;&amp;
                weakly_incrementable&lt;iterator_t&lt;ORng&gt;&gt; &amp;&amp;
                indirectly_copyable&lt;I, iterator_t&lt;ORng&gt;&gt; &amp;&amp;
                uniform_random_bit_generator&lt;std::remove_reference_t&lt;Gen&gt;&gt; &amp;&amp;
                (forward_range&lt;ORng&gt; ||
                 sized_range&lt;ORng&gt;)&amp;&amp;(random_access_iterator&lt;iterator_t&lt;ORng&gt;&gt; ||
                                      forward_iterator&lt;I&gt; || sized_sentinel_for&lt;S, I&gt;) 
        </td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="algorithm_2sample_8hpp.html">range/v3/algorithm/sample.hpp</a>&gt;</code></p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="ga6699f9e02f0ebcb00a92417eccf6725c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6699f9e02f0ebcb00a92417eccf6725c">&#9670;&nbsp;</a></span>sample() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng , typename O , typename Gen  = detail::default_random_engine &amp;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classauto.html">auto</a> ranges::sample </td>
          <td>(</td>
          <td class="paramtype">Rng &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">O&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">iter_difference_t&lt; O &gt; const&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Gen &amp;&amp;&#160;</td>
          <td class="paramname"><em>gen</em> = <code>detail::get_random_engine()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; sample_result&lt;safe_iterator_t&lt;Rng&gt;, O&gt;   
                requires input_range&lt;Rng&gt; &amp;&amp; weakly_incrementable&lt;O&gt; &amp;&amp;
                indirectly_copyable&lt;iterator_t&lt;Rng&gt;, O&gt; &amp;&amp;
                uniform_random_bit_generator&lt;std::remove_reference_t&lt;Gen&gt;&gt; &amp;&amp;
                (random_access_iterator&lt;O&gt; || forward_range&lt;Rng&gt; || sized_range&lt;Rng&gt;) 
        </td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="algorithm_2sample_8hpp.html">range/v3/algorithm/sample.hpp</a>&gt;</code></p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="gadc045be30e4c526e3139fc9437082d3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadc045be30e4c526e3139fc9437082d3b">&#9670;&nbsp;</a></span>sample() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IRng , typename ORng , typename Gen  = detail::default_random_engine &amp;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classauto.html">auto</a> ranges::sample </td>
          <td>(</td>
          <td class="paramtype">IRng &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ORng &amp;&amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Gen &amp;&amp;&#160;</td>
          <td class="paramname"><em>gen</em> = <code>detail::get_random_engine()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; sample_result&lt;safe_iterator_t&lt;IRng&gt;, safe_iterator_t&lt;ORng&gt;&gt;   
                requires input_range&lt;IRng&gt; &amp;&amp; range&lt;ORng&gt; &amp;&amp;
                indirectly_copyable&lt;iterator_t&lt;IRng&gt;, iterator_t&lt;ORng&gt;&gt; &amp;&amp;
                uniform_random_bit_generator&lt;std::remove_reference_t&lt;Gen&gt;&gt; &amp;&amp;
                (random_access_iterator&lt;iterator_t&lt;ORng&gt;&gt; || forward_range&lt;IRng&gt; ||
                 sized_range&lt;IRng&gt;)&amp;&amp;(forward_range&lt;ORng&gt; || sized_range&lt;ORng&gt;) 
        </td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="algorithm_2sample_8hpp.html">range/v3/algorithm/sample.hpp</a>&gt;</code></p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="ga29228b9cd4dadf9e2d1e335d9d24b0b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga29228b9cd4dadf9e2d1e335d9d24b0b7">&#9670;&nbsp;</a></span>search()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng1 , typename Rng2 , typename C  = equal_to, typename P1  = identity, typename P2  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classauto.html">auto</a> ranges::search </td>
          <td>(</td>
          <td class="paramtype">Rng1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Rng2 &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em> = <code>C{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P1&#160;</td>
          <td class="paramname"><em>proj1</em> = <code>P1{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P2&#160;</td>
          <td class="paramname"><em>proj2</em> = <code>P2{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; safe_subrange_t&lt;Rng1&gt;   
                requires forward_range&lt;Rng1&gt; &amp;&amp; forward_range&lt;Rng2&gt; &amp;&amp;
                indirectly_comparable&lt;iterator_t&lt;Rng1&gt;, iterator_t&lt;Rng2&gt;, C, P1, P2&gt; 
        </td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="search_8hpp.html">range/v3/algorithm/search.hpp</a>&gt;</code></p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="ga0187451967b3403c72c0d76a49dd1a13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0187451967b3403c72c0d76a49dd1a13">&#9670;&nbsp;</a></span>search_n()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng , typename V , typename C  = equal_to, typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classauto.html">auto</a> ranges::search_n </td>
          <td>(</td>
          <td class="paramtype">Rng &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">iter_difference_t&lt; iterator_t&lt; Rng &gt;&gt;&#160;</td>
          <td class="paramname"><em>cnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">V const &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em> = <code>C{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; safe_subrange_t&lt;Rng&gt;   
                requires forward_range&lt;Rng&gt; &amp;&amp;
                indirectly_comparable&lt;iterator_t&lt;Rng&gt;, V const *, C, P&gt; 
        </td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="search__n_8hpp.html">range/v3/algorithm/search_n.hpp</a>&gt;</code></p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="gae475cf785478cfed790cfb6c1343e43a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae475cf785478cfed790cfb6c1343e43a">&#9670;&nbsp;</a></span>set_difference()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng1 , typename Rng2 , typename O , typename C  = less, typename P1  = identity, typename P2  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classauto.html">auto</a> ranges::set_difference </td>
          <td>(</td>
          <td class="paramtype">Rng1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Rng2 &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">O&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em> = <code>C{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P1&#160;</td>
          <td class="paramname"><em>proj1</em> = <code>P1{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P2&#160;</td>
          <td class="paramname"><em>proj2</em> = <code>P2{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; set_difference_result&lt;safe_iterator_t&lt;Rng1&gt;, O&gt;   
                requires range&lt;Rng1&gt; &amp;&amp; range&lt;Rng2&gt; &amp;&amp;
                mergeable&lt;iterator_t&lt;Rng1&gt;, iterator_t&lt;Rng2&gt;, O, C, P1, P2&gt; 
        </td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="algorithm_2set__algorithm_8hpp.html">range/v3/algorithm/set_algorithm.hpp</a>&gt;</code></p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="ga16ff3992a9314dcf174835b3a6e05245"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga16ff3992a9314dcf174835b3a6e05245">&#9670;&nbsp;</a></span>set_intersection()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng1 , typename Rng2 , typename O , typename C  = less, typename P1  = identity, typename P2  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classauto.html">auto</a> ranges::set_intersection </td>
          <td>(</td>
          <td class="paramtype">Rng1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Rng2 &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">O&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em> = <code>C{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P1&#160;</td>
          <td class="paramname"><em>proj1</em> = <code>P1{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P2&#160;</td>
          <td class="paramname"><em>proj2</em> = <code>P2{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; O   
                requires range&lt;Rng1&gt; &amp;&amp; range&lt;Rng2&gt; &amp;&amp;
                mergeable&lt;iterator_t&lt;Rng1&gt;, iterator_t&lt;Rng2&gt;, O, C, P1, P2&gt; 
        </td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="algorithm_2set__algorithm_8hpp.html">range/v3/algorithm/set_algorithm.hpp</a>&gt;</code></p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="ga038044a963f0b10fc883cf57ed0b01aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga038044a963f0b10fc883cf57ed0b01aa">&#9670;&nbsp;</a></span>set_symmetric_difference()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng1 , typename Rng2 , typename O , typename C  = less, typename P1  = identity, typename P2  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classauto.html">auto</a> ranges::set_symmetric_difference </td>
          <td>(</td>
          <td class="paramtype">Rng1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Rng2 &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">O&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em> = <code>C{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P1&#160;</td>
          <td class="paramname"><em>proj1</em> = <code>P1{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P2&#160;</td>
          <td class="paramname"><em>proj2</em> = <code>P2{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; set_symmetric_difference_result&lt;safe_iterator_t&lt;Rng1&gt;,                                                       safe_iterator_t&lt;Rng2&gt;,                                                       O&gt;   
                requires range&lt;Rng1&gt; &amp;&amp; range&lt;Rng2&gt; &amp;&amp;
                mergeable&lt;iterator_t&lt;Rng1&gt;, iterator_t&lt;Rng2&gt;, O, C, P1, P2&gt; 
        </td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="algorithm_2set__algorithm_8hpp.html">range/v3/algorithm/set_algorithm.hpp</a>&gt;</code></p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="gabb1192300ac92c87a8ff922580465e2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabb1192300ac92c87a8ff922580465e2d">&#9670;&nbsp;</a></span>set_union()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng1 , typename Rng2 , typename O , typename C  = less, typename P1  = identity, typename P2  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classauto.html">auto</a> ranges::set_union </td>
          <td>(</td>
          <td class="paramtype">Rng1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Rng2 &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">O&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em> = <code>C{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P1&#160;</td>
          <td class="paramname"><em>proj1</em> = <code>P1{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P2&#160;</td>
          <td class="paramname"><em>proj2</em> = <code>P2{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; set_union_result&lt;safe_iterator_t&lt;Rng1&gt;, safe_iterator_t&lt;Rng2&gt;, O&gt;   
                requires range&lt;Rng1&gt; &amp;&amp; range&lt;Rng2&gt; &amp;&amp;
                mergeable&lt;iterator_t&lt;Rng1&gt;, iterator_t&lt;Rng2&gt;, O, C, P1, P2&gt; 
        </td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="algorithm_2set__algorithm_8hpp.html">range/v3/algorithm/set_algorithm.hpp</a>&gt;</code></p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="ga93fd2433ca21a7105bf67aca57c4ecad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga93fd2433ca21a7105bf67aca57c4ecad">&#9670;&nbsp;</a></span>shuffle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng , typename Gen  = detail::default_random_engine &amp;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classauto.html">auto</a> ranges::shuffle </td>
          <td>(</td>
          <td class="paramtype">Rng &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Gen &amp;&amp;&#160;</td>
          <td class="paramname"><em>rand</em> = <code>detail::get_random_engine()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; safe_iterator_t&lt;Rng&gt;   
                requires random_access_range&lt;Rng&gt; &amp;&amp; permutable&lt;iterator_t&lt;Rng&gt;&gt; &amp;&amp;
                uniform_random_bit_generator&lt;std::remove_reference_t&lt;Gen&gt;&gt; &amp;&amp;
                convertible_to&lt;invoke_result_t&lt;Gen &amp;&gt;,
                               iter_difference_t&lt;iterator_t&lt;Rng&gt;&gt;&gt; 
        </td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="algorithm_2shuffle_8hpp.html">range/v3/algorithm/shuffle.hpp</a>&gt;</code></p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="ga0fda77d6d9ad1a234b712d92c949ea37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0fda77d6d9ad1a234b712d92c949ea37">&#9670;&nbsp;</a></span>sort()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng , typename C  = less, typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classauto.html">auto</a> ranges::sort </td>
          <td>(</td>
          <td class="paramtype">Rng &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em> = <code>C{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; safe_iterator_t&lt;Rng&gt;   
                requires sortable&lt;iterator_t&lt;Rng&gt;, C, P&gt; &amp;&amp; random_access_range&lt;Rng&gt; 
        </td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="algorithm_2sort_8hpp.html">range/v3/algorithm/sort.hpp</a>&gt;</code></p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="ga39738e10668ac14c55c17a554ae72a55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga39738e10668ac14c55c17a554ae72a55">&#9670;&nbsp;</a></span>stable_sort()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng , typename C  = less, typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classauto.html">auto</a> ranges::stable_sort </td>
          <td>(</td>
          <td class="paramtype">Rng &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em> = <code>C{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; safe_iterator_t&lt;Rng&gt;   
                requires sortable&lt;iterator_t&lt;Rng&gt;, C, P&gt; &amp;&amp; random_access_range&lt;Rng&gt; 
        </td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="algorithm_2stable__sort_8hpp.html">range/v3/algorithm/stable_sort.hpp</a>&gt;</code></p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="ga762b17eda45efa20b8e7407da1d3a249"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga762b17eda45efa20b8e7407da1d3a249">&#9670;&nbsp;</a></span>starts_with()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R1 , typename R2 , typename Comp  = equal_to, typename Proj1  = identity, typename Proj2  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classauto.html">auto</a> ranges::starts_with </td>
          <td>(</td>
          <td class="paramtype">R1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>r1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R2 &amp;&amp;&#160;</td>
          <td class="paramname"><em>r2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Comp&#160;</td>
          <td class="paramname"><em>comp</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Proj1&#160;</td>
          <td class="paramname"><em>proj1</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Proj2&#160;</td>
          <td class="paramname"><em>proj2</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool   
                requires input_range&lt;R1&gt; &amp;&amp; input_range&lt;R2&gt; &amp;&amp;
                indirectly_comparable&lt;iterator_t&lt;R1&gt;, iterator_t&lt;R2&gt;, Comp, Proj1, Proj2&gt; 
        </td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;range/v3/algorithm/starts_with.hpp&gt;</code></p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="gac6c5f3296682ac14499cb0e7c39348ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac6c5f3296682ac14499cb0e7c39348ae">&#9670;&nbsp;</a></span>swap_ranges()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I1 , typename S1 , typename I2 , typename S2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classauto.html">auto</a> ranges::swap_ranges </td>
          <td>(</td>
          <td class="paramtype">I1&#160;</td>
          <td class="paramname"><em>begin1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S1&#160;</td>
          <td class="paramname"><em>end1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I2&#160;</td>
          <td class="paramname"><em>begin2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S2&#160;</td>
          <td class="paramname"><em>end2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; swap_ranges_result&lt;I1, I2&gt;   
                requires input_iterator&lt;I1&gt; &amp;&amp; sentinel_for&lt;S1, I1&gt; &amp;&amp;
                input_iterator&lt;I2&gt; &amp;&amp; sentinel_for&lt;S2, I2&gt; &amp;&amp;
                indirectly_swappable&lt;I1, I2&gt; 
        </td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="swap__ranges_8hpp.html">range/v3/algorithm/swap_ranges.hpp</a>&gt;</code></p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="gac8c39da8594063d3c568ed06deaa453d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac8c39da8594063d3c568ed06deaa453d">&#9670;&nbsp;</a></span>transform() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng , typename O , typename F , typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classauto.html">auto</a> ranges::transform </td>
          <td>(</td>
          <td class="paramtype">Rng &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">O&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; unary_transform_result&lt;safe_iterator_t&lt;Rng&gt;, O&gt;   
                requires input_range&lt;Rng&gt; &amp;&amp; weakly_incrementable&lt;O&gt; &amp;&amp;
                copy_constructible&lt;F&gt; &amp;&amp;
                writable&lt;O, indirect_result_t&lt;F &amp;, projected&lt;iterator_t&lt;Rng&gt;, P&gt;&gt;&gt; 
        </td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="algorithm_2transform_8hpp.html">range/v3/algorithm/transform.hpp</a>&gt;</code></p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="gac4ce8886b2139e524a7a55d9533ecb17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac4ce8886b2139e524a7a55d9533ecb17">&#9670;&nbsp;</a></span>transform() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I0 , typename S0 , typename I1 , typename S1 , typename O , typename F , typename P0  = identity, typename P1  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classauto.html">auto</a> ranges::transform </td>
          <td>(</td>
          <td class="paramtype">I0&#160;</td>
          <td class="paramname"><em>begin0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S0&#160;</td>
          <td class="paramname"><em>end0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I1&#160;</td>
          <td class="paramname"><em>begin1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S1&#160;</td>
          <td class="paramname"><em>end1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">O&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P0&#160;</td>
          <td class="paramname"><em>proj0</em> = <code>P0{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P1&#160;</td>
          <td class="paramname"><em>proj1</em> = <code>P1{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; binary_transform_result&lt;I0, I1, O&gt;   
                requires input_iterator&lt;I0&gt; &amp;&amp; sentinel_for&lt;S0, I0&gt; &amp;&amp;
                input_iterator&lt;I1&gt; &amp;&amp; sentinel_for&lt;S1, I1&gt; &amp;&amp; weakly_incrementable&lt;O&gt; &amp;&amp;
                copy_constructible&lt;F&gt; &amp;&amp;
                writable&lt;O, indirect_result_t&lt;F &amp;, projected&lt;I0, P0&gt;, projected&lt;I1, P1&gt;&gt;&gt; 
        </td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="algorithm_2transform_8hpp.html">range/v3/algorithm/transform.hpp</a>&gt;</code></p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="ga45614e7d9ed220f702f59033a5c833db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga45614e7d9ed220f702f59033a5c833db">&#9670;&nbsp;</a></span>transform() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng0 , typename Rng1 , typename O , typename F , typename P0  = identity, typename P1  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classauto.html">auto</a> ranges::transform </td>
          <td>(</td>
          <td class="paramtype">Rng0 &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Rng1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">O&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P0&#160;</td>
          <td class="paramname"><em>proj0</em> = <code>P0{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P1&#160;</td>
          <td class="paramname"><em>proj1</em> = <code>P1{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; binary_transform_result&lt;safe_iterator_t&lt;Rng0&gt;,                                               safe_iterator_t&lt;Rng1&gt;,                                               O&gt;   
                requires input_range&lt;Rng0&gt; &amp;&amp; input_range&lt;Rng1&gt; &amp;&amp;
                weakly_incrementable&lt;O&gt; &amp;&amp; copy_constructible&lt;F&gt; &amp;&amp;
                writable&lt;O,
                         indirect_result_t&lt;F &amp;,
                                           projected&lt;iterator_t&lt;Rng0&gt;, P0&gt;,
                                           projected&lt;iterator_t&lt;Rng1&gt;, P1&gt;&gt;&gt; 
        </td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="algorithm_2transform_8hpp.html">range/v3/algorithm/transform.hpp</a>&gt;</code></p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="ga59baf93d7a2cbaa4457120a8da5414b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga59baf93d7a2cbaa4457120a8da5414b0">&#9670;&nbsp;</a></span>transform() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I0 , typename S0 , typename I1 , typename O , typename F , typename P0  = identity, typename P1  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classauto.html">auto</a> ranges::transform </td>
          <td>(</td>
          <td class="paramtype">I0&#160;</td>
          <td class="paramname"><em>begin0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S0&#160;</td>
          <td class="paramname"><em>end0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I1&#160;</td>
          <td class="paramname"><em>begin1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">O&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P0&#160;</td>
          <td class="paramname"><em>proj0</em> = <code>P0{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P1&#160;</td>
          <td class="paramname"><em>proj1</em> = <code>P1{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; binary_transform_result&lt;I0, I1, O&gt;   
                requires input_iterator&lt;I0&gt; &amp;&amp; sentinel_for&lt;S0, I0&gt; &amp;&amp;
                input_iterator&lt;I1&gt; &amp;&amp; weakly_incrementable&lt;O&gt; &amp;&amp; copy_constructible&lt;F&gt; &amp;&amp;
                writable&lt;O, indirect_result_t&lt;F &amp;, projected&lt;I0, P0&gt;, projected&lt;I1, P1&gt;&gt;&gt; 
        </td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="algorithm_2transform_8hpp.html">range/v3/algorithm/transform.hpp</a>&gt;</code></p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="gafa31831f1a06d2268c06a9a04981ed55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafa31831f1a06d2268c06a9a04981ed55">&#9670;&nbsp;</a></span>transform() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng0 , typename I1Ref , typename O , typename F , typename P0  = identity, typename P1  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classauto.html">auto</a> ranges::transform </td>
          <td>(</td>
          <td class="paramtype">Rng0 &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I1Ref &amp;&amp;&#160;</td>
          <td class="paramname"><em>begin1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">O&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P0&#160;</td>
          <td class="paramname"><em>proj0</em> = <code>P0{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P1&#160;</td>
          <td class="paramname"><em>proj1</em> = <code>P1{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; binary_transform_result&lt;safe_iterator_t&lt;Rng0&gt;, uncvref_t&lt;I1Ref&gt;, O&gt;   
                requires input_range&lt;Rng0&gt; &amp;&amp; input_iterator&lt;uncvref_t&lt;I1Ref&gt;&gt; &amp;&amp;
                weakly_incrementable&lt;O&gt; &amp;&amp; copy_constructible&lt;F&gt; &amp;&amp;
                writable&lt;O,
                         indirect_result_t&lt;F &amp;,
                                           projected&lt;iterator_t&lt;Rng0&gt;, P0&gt;,
                                           projected&lt;uncvref_t&lt;I1Ref&gt;, P1&gt;&gt;&gt; 
        </td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="algorithm_2transform_8hpp.html">range/v3/algorithm/transform.hpp</a>&gt;</code></p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="gae5e540912bea57a858b704e1b663ea01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae5e540912bea57a858b704e1b663ea01">&#9670;&nbsp;</a></span>unique() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename S , typename C  = equal_to, typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classauto.html">auto</a> ranges::unique </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em> = <code>C{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; I   
                requires sortable&lt;I, C, P&gt; &amp;&amp; sentinel_for&lt;S, I&gt; 
        </td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="algorithm_2unique_8hpp.html">range/v3/algorithm/unique.hpp</a>&gt;</code></p>

<p>template function <code>unique</code> </p>
<p>range-based version of the <code>unique</code> std algorithm</p>
<dl class="section pre"><dt>Precondition</dt><dd><code>Rng</code> is a model of the <code>forward_range</code> concept </dd>
<dd>
<code>I</code> is a model of the <code>forward_iterator</code> concept </dd>
<dd>
<code>S</code> is a model of the <code>sentinel_for</code> concept </dd>
<dd>
<code>C</code> is a model of the <code>relation</code> concept </dd></dl>

</div>
</div>
<a id="gade22082168ffc3e0710b7181732cf979"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gade22082168ffc3e0710b7181732cf979">&#9670;&nbsp;</a></span>unique() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng , typename C  = equal_to, typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classauto.html">auto</a> ranges::unique </td>
          <td>(</td>
          <td class="paramtype">Rng &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em> = <code>C{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; safe_iterator_t&lt;Rng&gt;   
                requires sortable&lt;iterator_t&lt;Rng&gt;, C, P&gt; &amp;&amp; range&lt;Rng&gt; 
        </td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="algorithm_2unique_8hpp.html">range/v3/algorithm/unique.hpp</a>&gt;</code></p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="gafe19943e4d2efa41533b2d068dc268c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafe19943e4d2efa41533b2d068dc268c4">&#9670;&nbsp;</a></span>unique_copy() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename S , typename O , typename C  = equal_to, typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classauto.html">auto</a> ranges::unique_copy </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">O&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em> = <code>C{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; unique_copy_result&lt;I, O&gt;   
                requires input_iterator&lt;I&gt; &amp;&amp; sentinel_for&lt;S, I&gt; &amp;&amp;
                indirect_relation&lt;C, projected&lt;I, P&gt;&gt; &amp;&amp; weakly_incrementable&lt;O&gt; &amp;&amp;
                indirectly_copyable&lt;I, O&gt; &amp;&amp;
                (forward_iterator&lt;I&gt; || forward_iterator&lt;O&gt; ||
                 indirectly_copyable_storable&lt;I, O&gt;) 
        </td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="unique__copy_8hpp.html">range/v3/algorithm/unique_copy.hpp</a>&gt;</code></p>

<p>template function unique_copy </p>
<p>range-based version of the <code>unique_copy</code> std algorithm</p>
<dl class="section pre"><dt>Precondition</dt><dd><code>Rng</code> is a model of the <code>input_range</code> concept </dd>
<dd>
<code>O</code> is a model of the <code>weakly_incrementable</code> concept </dd>
<dd>
<code>C</code> is a model of the <code>relation</code> concept </dd></dl>

</div>
</div>
<a id="ga4cb85c9a5ce8c5773f1f7f8fa9d6ef15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4cb85c9a5ce8c5773f1f7f8fa9d6ef15">&#9670;&nbsp;</a></span>unique_copy() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng , typename O , typename C  = equal_to, typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classauto.html">auto</a> ranges::unique_copy </td>
          <td>(</td>
          <td class="paramtype">Rng &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">O&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em> = <code>C{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; unique_copy_result&lt;safe_iterator_t&lt;Rng&gt;, O&gt;   
                requires input_range&lt;Rng&gt; &amp;&amp;
                indirect_relation&lt;C, projected&lt;iterator_t&lt;Rng&gt;, P&gt;&gt; &amp;&amp;
                weakly_incrementable&lt;O&gt; &amp;&amp; indirectly_copyable&lt;iterator_t&lt;Rng&gt;, O&gt; &amp;&amp;
                (forward_iterator&lt;iterator_t&lt;Rng&gt;&gt; || forward_iterator&lt;O&gt; ||
                 indirectly_copyable_storable&lt;iterator_t&lt;Rng&gt;, O&gt;) 
        </td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="unique__copy_8hpp.html">range/v3/algorithm/unique_copy.hpp</a>&gt;</code></p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="gaef222b7bf5356fd2124bf661a359d730"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaef222b7bf5356fd2124bf661a359d730">&#9670;&nbsp;</a></span>unstable_remove_if() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename C , typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classauto.html">auto</a> ranges::unstable_remove_if </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; I   
                requires bidirectional_iterator&lt;I&gt; &amp;&amp; permutable&lt;I&gt; &amp;&amp;
                indirect_unary_predicate&lt;C, projected&lt;I, P&gt;&gt; 
        </td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="algorithm_2unstable__remove__if_8hpp.html">range/v3/algorithm/unstable_remove_if.hpp</a>&gt;</code></p>

<p>unstable_remove have O(1) complexity for each element remove, unlike remove O(n) [for worst case]. Each erased element overwritten (moved in) with last one. unstable_remove_if does not preserve relative element order. </p>
<p>function template <code>unstable_remove_if</code> </p>

</div>
</div>
<a id="ga93307fbcec220cfea80936970d4c8d1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga93307fbcec220cfea80936970d4c8d1a">&#9670;&nbsp;</a></span>unstable_remove_if() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng , typename C , typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classauto.html">auto</a> ranges::unstable_remove_if </td>
          <td>(</td>
          <td class="paramtype">Rng &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; safe_iterator_t&lt;Rng&gt;   
                requires bidirectional_range&lt;Rng&gt; &amp;&amp; common_range&lt;Rng&gt; &amp;&amp;
                permutable&lt;iterator_t&lt;Rng&gt;&gt; &amp;&amp;
                indirect_unary_predicate&lt;C, projected&lt;iterator_t&lt;Rng&gt;, P&gt;&gt; 
        </td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="algorithm_2unstable__remove__if_8hpp.html">range/v3/algorithm/unstable_remove_if.hpp</a>&gt;</code></p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="ga1fcb1018d6953624f46428fe9956e04b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1fcb1018d6953624f46428fe9956e04b">&#9670;&nbsp;</a></span>upper_bound()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng , typename V , typename C  = less, typename P  = identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classauto.html">auto</a> ranges::upper_bound </td>
          <td>(</td>
          <td class="paramtype">Rng &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">V const &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em> = <code>C{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; safe_iterator_t&lt;Rng&gt;   
                requires forward_range&lt;Rng&gt; &amp;&amp;
                indirect_strict_weak_order&lt;C, V const *, projected&lt;iterator_t&lt;Rng&gt;, P&gt;&gt; 
        </td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="upper__bound_8hpp.html">range/v3/algorithm/upper_bound.hpp</a>&gt;</code></p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.15 </li>
  </ul>
</div>
</body>
</html>
